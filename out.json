{
  "results": [
    {
      "title": "Balanced Binary Tree",
      "titleSlug": "balanced-binary-tree",
      "difficulty": "Easy",
      "content": "\u003cp\u003eGiven a binary tree, determine if it is \u003cspan data-keyword=\"height-balanced\"\u003e\u003cstrong\u003eheight-balanced\u003c/strong\u003e\u003c/span\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg\" style=\"width: 342px; height: 221px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [3,9,20,null,null,15,7]\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg\" style=\"width: 452px; height: 301px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2,2,3,3,null,null,4,4]\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = []\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[0, 5000]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e4\u003c/sup\u003e \u0026lt;= Node.val \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": ["Tree", "Depth-First Search", "Binary Tree"]
    },
    {
      "title": "Invert Binary Tree",
      "titleSlug": "invert-binary-tree",
      "difficulty": "Easy",
      "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a binary tree, invert the tree, and return \u003cem\u003eits root\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg\" style=\"width: 500px; height: 165px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [4,2,7,1,3,6,9]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [4,7,2,9,6,3,1]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg\" style=\"width: 500px; height: 120px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [2,1,3]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [2,3,1]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = []\n\u003cstrong\u003eOutput:\u003c/strong\u003e []\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[0, 100]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-100 \u0026lt;= Node.val \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ]
    },
    {
      "title": "Binary Tree Paths",
      "titleSlug": "binary-tree-paths",
      "difficulty": "Easy",
      "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a binary tree, return \u003cem\u003eall root-to-leaf paths in \u003cstrong\u003eany order\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eA \u003cstrong\u003eleaf\u003c/strong\u003e is a node with no children.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg\" style=\"width: 207px; height: 293px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2,3,null,5]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [\u0026quot;1-\u0026gt;2-\u0026gt;5\u0026quot;,\u0026quot;1-\u0026gt;3\u0026quot;]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [\u0026quot;1\u0026quot;]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 100]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-100 \u0026lt;= Node.val \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": [
        "String",
        "Backtracking",
        "Tree",
        "Depth-First Search",
        "Binary Tree"
      ]
    },
    {
      "title": "Univalued Binary Tree",
      "titleSlug": "univalued-binary-tree",
      "difficulty": "Easy",
      "content": "\u003cp\u003eA binary tree is \u003cstrong\u003euni-valued\u003c/strong\u003e if every node in the tree has the same value.\u003c/p\u003e\n\n\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a binary tree, return \u003ccode\u003etrue\u003c/code\u003e\u003cem\u003e if the given tree is \u003cstrong\u003euni-valued\u003c/strong\u003e, or \u003c/em\u003e\u003ccode\u003efalse\u003c/code\u003e\u003cem\u003e otherwise.\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/28/unival_bst_1.png\" style=\"width: 265px; height: 172px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,1,1,1,1,null,1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/28/unival_bst_2.png\" style=\"width: 198px; height: 169px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [2,2,2,5,2]\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 100]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= Node.val \u0026lt; 100\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ]
    },
    {
      "title": "Binary Tree Cameras",
      "titleSlug": "binary-tree-cameras",
      "difficulty": "Hard",
      "content": "\u003cp\u003eYou are given the \u003ccode\u003eroot\u003c/code\u003e of a binary tree. We install cameras on the tree nodes where each camera at a node can monitor its parent, itself, and its immediate children.\u003c/p\u003e\n\n\u003cp\u003eReturn \u003cem\u003ethe minimum number of cameras needed to monitor all nodes of the tree\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/29/bst_cameras_01.png\" style=\"width: 138px; height: 163px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [0,0,null,0,0]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 1\n\u003cstrong\u003eExplanation:\u003c/strong\u003e One camera is enough to monitor all nodes if placed as shown.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/29/bst_cameras_02.png\" style=\"width: 139px; height: 312px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [0,0,null,0,null,0,null,null,0]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2\n\u003cstrong\u003eExplanation:\u003c/strong\u003e At least two cameras are needed to monitor all nodes of the tree. The above image shows one of the valid configurations of camera placement.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 1000]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eNode.val == 0\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": [
        "Dynamic Programming",
        "Tree",
        "Depth-First Search",
        "Binary Tree"
      ]
    },
    {
      "title": "Binary Tree Tilt",
      "titleSlug": "binary-tree-tilt",
      "difficulty": "Easy",
      "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a binary tree, return \u003cem\u003ethe sum of every tree node\u0026#39;s \u003cstrong\u003etilt\u003c/strong\u003e.\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003eThe \u003cstrong\u003etilt\u003c/strong\u003e of a tree node is the \u003cstrong\u003eabsolute difference\u003c/strong\u003e between the sum of all left subtree node \u003cstrong\u003evalues\u003c/strong\u003e and all right subtree node \u003cstrong\u003evalues\u003c/strong\u003e. If a node does not have a left child, then the sum of the left subtree node \u003cstrong\u003evalues\u003c/strong\u003e is treated as \u003ccode\u003e0\u003c/code\u003e. The rule is similar if the node does not have a right child.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/20/tilt1.jpg\" style=\"width: 712px; height: 182px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2,3]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 1\n\u003cstrong\u003eExplanation:\u003c/strong\u003e \nTilt of node 2 : |0-0| = 0 (no children)\nTilt of node 3 : |0-0| = 0 (no children)\nTilt of node 1 : |2-3| = 1 (left subtree is just left child, so sum is 2; right subtree is just right child, so sum is 3)\nSum of every tilt : 0 + 0 + 1 = 1\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/20/tilt2.jpg\" style=\"width: 800px; height: 203px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [4,2,9,3,5,null,7]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 15\n\u003cstrong\u003eExplanation:\u003c/strong\u003e \nTilt of node 3 : |0-0| = 0 (no children)\nTilt of node 5 : |0-0| = 0 (no children)\nTilt of node 7 : |0-0| = 0 (no children)\nTilt of node 2 : |3-5| = 2 (left subtree is just left child, so sum is 3; right subtree is just right child, so sum is 5)\nTilt of node 9 : |0-7| = 7 (no left child, so sum is 0; right subtree is just right child, so sum is 7)\nTilt of node 4 : |(3+5+2)-(9+7)| = |10-16| = 6 (left subtree values are 3, 5, and 2, which sums to 10; right subtree values are 9 and 7, which sums to 16)\nSum of every tilt : 0 + 0 + 0 + 2 + 7 + 6 = 15\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/20/tilt3.jpg\" style=\"width: 800px; height: 293px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [21,7,14,1,1,2,2,3,3]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 9\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[0, 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-1000 \u0026lt;= Node.val \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": ["Tree", "Depth-First Search", "Binary Tree"]
    },
    {
      "title": "Maximum Binary Tree",
      "titleSlug": "maximum-binary-tree",
      "difficulty": "Medium",
      "content": "\u003cp\u003eYou are given an integer array \u003ccode\u003enums\u003c/code\u003e with no duplicates. A \u003cstrong\u003emaximum binary tree\u003c/strong\u003e can be built recursively from \u003ccode\u003enums\u003c/code\u003e using the following algorithm:\u003c/p\u003e\n\n\u003col\u003e\n\t\u003cli\u003eCreate a root node whose value is the maximum value in \u003ccode\u003enums\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003eRecursively build the left subtree on the \u003cstrong\u003esubarray prefix\u003c/strong\u003e to the \u003cstrong\u003eleft\u003c/strong\u003e of the maximum value.\u003c/li\u003e\n\t\u003cli\u003eRecursively build the right subtree on the \u003cstrong\u003esubarray suffix\u003c/strong\u003e to the \u003cstrong\u003eright\u003c/strong\u003e of the maximum value.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eReturn \u003cem\u003ethe \u003cstrong\u003emaximum binary tree\u003c/strong\u003e built from \u003c/em\u003e\u003ccode\u003enums\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg\" style=\"width: 302px; height: 421px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums = [3,2,1,6,0,5]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [6,3,5,null,2,0,null,null,1]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The recursive calls are as follow:\n- The largest value in [3,2,1,6,0,5] is 6. Left prefix is [3,2,1] and right suffix is [0,5].\n    - The largest value in [3,2,1] is 3. Left prefix is [] and right suffix is [2,1].\n        - Empty array, so no child.\n        - The largest value in [2,1] is 2. Left prefix is [] and right suffix is [1].\n            - Empty array, so no child.\n            - Only one element, so child is a node with value 1.\n    - The largest value in [0,5] is 5. Left prefix is [0] and right suffix is [].\n        - Only one element, so child is a node with value 0.\n        - Empty array, so no child.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg\" style=\"width: 182px; height: 301px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums = [3,2,1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [3,null,2,null,1]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums.length \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= nums[i] \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eAll integers in \u003ccode\u003enums\u003c/code\u003e are \u003cstrong\u003eunique\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": [
        "Array",
        "Divide and Conquer",
        "Stack",
        "Tree",
        "Monotonic Stack",
        "Binary Tree"
      ]
    },
    {
      "title": "Print Binary Tree",
      "titleSlug": "print-binary-tree",
      "difficulty": "Medium",
      "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a binary tree, construct a \u003cstrong\u003e0-indexed\u003c/strong\u003e \u003ccode\u003em x n\u003c/code\u003e string matrix \u003ccode\u003eres\u003c/code\u003e that represents a \u003cstrong\u003eformatted layout\u003c/strong\u003e of the tree. The formatted layout matrix should be constructed using the following rules:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe \u003cstrong\u003eheight\u003c/strong\u003e of the tree is \u003ccode\u003eheight\u003c/code\u003e\u0026nbsp;and the number of rows \u003ccode\u003em\u003c/code\u003e should be equal to \u003ccode\u003eheight + 1\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003eThe number of columns \u003ccode\u003en\u003c/code\u003e should be equal to \u003ccode\u003e2\u003csup\u003eheight+1\u003c/sup\u003e - 1\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003ePlace the \u003cstrong\u003eroot node\u003c/strong\u003e in the \u003cstrong\u003emiddle\u003c/strong\u003e of the \u003cstrong\u003etop row\u003c/strong\u003e (more formally, at location \u003ccode\u003eres[0][(n-1)/2]\u003c/code\u003e).\u003c/li\u003e\n\t\u003cli\u003eFor each node that has been placed in the matrix at position \u003ccode\u003eres[r][c]\u003c/code\u003e, place its \u003cstrong\u003eleft child\u003c/strong\u003e at \u003ccode\u003eres[r+1][c-2\u003csup\u003eheight-r-1\u003c/sup\u003e]\u003c/code\u003e and its \u003cstrong\u003eright child\u003c/strong\u003e at \u003ccode\u003eres[r+1][c+2\u003csup\u003eheight-r-1\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003eContinue this process until all the nodes in the tree have been placed.\u003c/li\u003e\n\t\u003cli\u003eAny empty cells should contain the empty string \u003ccode\u003e\u0026quot;\u0026quot;\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eReturn \u003cem\u003ethe constructed matrix \u003c/em\u003e\u003ccode\u003eres\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/print1-tree.jpg\" style=\"width: 141px; height: 181px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2]\n\u003cstrong\u003eOutput:\u003c/strong\u003e \n[[\u0026quot;\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;\u0026quot;],\n\u0026nbsp;[\u0026quot;2\u0026quot;,\u0026quot;\u0026quot;,\u0026quot;\u0026quot;]]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/print2-tree.jpg\" style=\"width: 207px; height: 302px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2,3,null,4]\n\u003cstrong\u003eOutput:\u003c/strong\u003e \n[[\u0026quot;\u0026quot;,\u0026quot;\u0026quot;,\u0026quot;\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;\u0026quot;,\u0026quot;\u0026quot;,\u0026quot;\u0026quot;],\n\u0026nbsp;[\u0026quot;\u0026quot;,\u0026quot;2\u0026quot;,\u0026quot;\u0026quot;,\u0026quot;\u0026quot;,\u0026quot;\u0026quot;,\u0026quot;3\u0026quot;,\u0026quot;\u0026quot;],\n\u0026nbsp;[\u0026quot;\u0026quot;,\u0026quot;\u0026quot;,\u0026quot;4\u0026quot;,\u0026quot;\u0026quot;,\u0026quot;\u0026quot;,\u0026quot;\u0026quot;,\u0026quot;\u0026quot;]]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 2\u003csup\u003e10\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-99 \u0026lt;= Node.val \u0026lt;= 99\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eThe depth of the tree will be in the range \u003ccode\u003e[1, 10]\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ]
    },
    {
      "title": "Binary Tree Pruning",
      "titleSlug": "binary-tree-pruning",
      "difficulty": "Medium",
      "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a binary tree, return \u003cem\u003ethe same tree where every subtree (of the given tree) not containing a \u003c/em\u003e\u003ccode\u003e1\u003c/code\u003e\u003cem\u003e has been removed\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eA subtree of a node \u003ccode\u003enode\u003c/code\u003e is \u003ccode\u003enode\u003c/code\u003e plus every node that is a descendant of \u003ccode\u003enode\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/06/1028_2.png\" style=\"width: 500px; height: 140px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,null,0,0,1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,null,0,null,1]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e \nOnly the red nodes satisfy the property \u0026quot;every subtree not containing a 1\u0026quot;.\nThe diagram on the right represents the answer.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/06/1028_1.png\" style=\"width: 500px; height: 115px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,0,1,0,0,0,1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,null,1,null,1]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/05/1028.png\" style=\"width: 500px; height: 134px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,1,0,1,1,0,1,0]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,1,0,1,1,null,1]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 200]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eNode.val\u003c/code\u003e is either \u003ccode\u003e0\u003c/code\u003e or \u003ccode\u003e1\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": ["Tree", "Depth-First Search", "Binary Tree"]
    },
    {
      "title": "Binary Tree Nodes",
      "titleSlug": "binary-tree-nodes",
      "difficulty": "Medium",
      "content": "",
      "tags": ["Database"]
    },
    {
      "title": "Binary Tree Inorder Traversal",
      "titleSlug": "binary-tree-inorder-traversal",
      "difficulty": "Easy",
      "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a binary tree, return \u003cem\u003ethe inorder traversal of its nodes\u0026#39; values\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cdiv class=\"example-block\"\u003e\n\u003cp\u003e\u003cstrong\u003eInput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003eroot = [1,null,2,3]\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eOutput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003e[1,3,2]\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eExplanation:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/08/29/screenshot-2024-08-29-202743.png\" style=\"width: 200px; height: 264px;\" /\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cdiv class=\"example-block\"\u003e\n\u003cp\u003e\u003cstrong\u003eInput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003eroot = [1,2,3,4,5,null,8,null,null,6,7,9]\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eOutput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003e[4,2,6,5,7,1,3,9,8]\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eExplanation:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/08/29/tree_2.png\" style=\"width: 350px; height: 286px;\" /\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cdiv class=\"example-block\"\u003e\n\u003cp\u003e\u003cstrong\u003eInput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003eroot = []\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eOutput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003e[]\u003c/span\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 4:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cdiv class=\"example-block\"\u003e\n\u003cp\u003e\u003cstrong\u003eInput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003eroot = [1]\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eOutput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003e[1]\u003c/span\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[0, 100]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-100 \u0026lt;= Node.val \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cstrong\u003eFollow up:\u003c/strong\u003e Recursive solution is trivial, could you do it iteratively?",
      "tags": ["Stack", "Tree", "Depth-First Search", "Binary Tree"]
    },
    {
      "title": "Binary Tree Preorder Traversal",
      "titleSlug": "binary-tree-preorder-traversal",
      "difficulty": "Easy",
      "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a binary tree, return \u003cem\u003ethe preorder traversal of its nodes\u0026#39; values\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cdiv class=\"example-block\"\u003e\n\u003cp\u003e\u003cstrong\u003eInput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003eroot = [1,null,2,3]\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eOutput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003e[1,2,3]\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eExplanation:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/08/29/screenshot-2024-08-29-202743.png\" style=\"width: 200px; height: 264px;\" /\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cdiv class=\"example-block\"\u003e\n\u003cp\u003e\u003cstrong\u003eInput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003eroot = [1,2,3,4,5,null,8,null,null,6,7,9]\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eOutput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003e[1,2,4,5,6,7,3,8,9]\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eExplanation:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/08/29/tree_2.png\" style=\"width: 350px; height: 286px;\" /\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cdiv class=\"example-block\"\u003e\n\u003cp\u003e\u003cstrong\u003eInput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003eroot = []\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eOutput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003e[]\u003c/span\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 4:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cdiv class=\"example-block\"\u003e\n\u003cp\u003e\u003cstrong\u003eInput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003eroot = [1]\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eOutput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003e[1]\u003c/span\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[0, 100]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-100 \u0026lt;= Node.val \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFollow up:\u003c/strong\u003e Recursive solution is trivial, could you do it iteratively?\u003c/p\u003e\n",
      "tags": ["Stack", "Tree", "Depth-First Search", "Binary Tree"]
    },
    {
      "title": "Binary Tree Postorder Traversal",
      "titleSlug": "binary-tree-postorder-traversal",
      "difficulty": "Easy",
      "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a\u0026nbsp;binary tree, return \u003cem\u003ethe postorder traversal of its nodes\u0026#39; values\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cdiv class=\"example-block\"\u003e\n\u003cp\u003e\u003cstrong\u003eInput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003eroot = [1,null,2,3]\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eOutput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003e[3,2,1]\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eExplanation:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/08/29/screenshot-2024-08-29-202743.png\" style=\"width: 200px; height: 264px;\" /\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cdiv class=\"example-block\"\u003e\n\u003cp\u003e\u003cstrong\u003eInput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003eroot = [1,2,3,4,5,null,8,null,null,6,7,9]\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eOutput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003e[4,6,7,5,2,9,8,3,1]\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eExplanation:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/08/29/tree_2.png\" style=\"width: 350px; height: 286px;\" /\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cdiv class=\"example-block\"\u003e\n\u003cp\u003e\u003cstrong\u003eInput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003eroot = []\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eOutput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003e[]\u003c/span\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 4:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cdiv class=\"example-block\"\u003e\n\u003cp\u003e\u003cstrong\u003eInput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003eroot = [1]\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eOutput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003e[1]\u003c/span\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of the nodes in the tree is in the range \u003ccode\u003e[0, 100]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-100 \u0026lt;= Node.val \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cstrong\u003eFollow up:\u003c/strong\u003e Recursive solution is trivial, could you do it iteratively?",
      "tags": ["Stack", "Tree", "Depth-First Search", "Binary Tree"]
    },
    {
      "title": "Binary Tree Upside Down",
      "titleSlug": "binary-tree-upside-down",
      "difficulty": "Medium",
      "content": "",
      "tags": ["Tree", "Depth-First Search", "Binary Tree"]
    },
    {
      "title": "Evaluate Boolean Binary Tree",
      "titleSlug": "evaluate-boolean-binary-tree",
      "difficulty": "Easy",
      "content": "\u003cp\u003eYou are given the \u003ccode\u003eroot\u003c/code\u003e of a \u003cstrong\u003efull binary tree\u003c/strong\u003e with the following properties:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003cstrong\u003eLeaf nodes\u003c/strong\u003e have either the value \u003ccode\u003e0\u003c/code\u003e or \u003ccode\u003e1\u003c/code\u003e, where \u003ccode\u003e0\u003c/code\u003e represents \u003ccode\u003eFalse\u003c/code\u003e and \u003ccode\u003e1\u003c/code\u003e represents \u003ccode\u003eTrue\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003cstrong\u003eNon-leaf nodes\u003c/strong\u003e have either the value \u003ccode\u003e2\u003c/code\u003e or \u003ccode\u003e3\u003c/code\u003e, where \u003ccode\u003e2\u003c/code\u003e represents the boolean \u003ccode\u003eOR\u003c/code\u003e and \u003ccode\u003e3\u003c/code\u003e represents the boolean \u003ccode\u003eAND\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThe \u003cstrong\u003eevaluation\u003c/strong\u003e of a node is as follows:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eIf the node is a leaf node, the evaluation is the \u003cstrong\u003evalue\u003c/strong\u003e of the node, i.e. \u003ccode\u003eTrue\u003c/code\u003e or \u003ccode\u003eFalse\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003eOtherwise, \u003cstrong\u003eevaluate\u003c/strong\u003e the node\u0026#39;s two children and \u003cstrong\u003eapply\u003c/strong\u003e the boolean operation of its value with the children\u0026#39;s evaluations.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eReturn\u003cem\u003e the boolean result of \u003cstrong\u003eevaluating\u003c/strong\u003e the \u003c/em\u003e\u003ccode\u003eroot\u003c/code\u003e\u003cem\u003e node.\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003eA \u003cstrong\u003efull binary tree\u003c/strong\u003e is a binary tree where each node has either \u003ccode\u003e0\u003c/code\u003e or \u003ccode\u003e2\u003c/code\u003e children.\u003c/p\u003e\n\n\u003cp\u003eA \u003cstrong\u003eleaf node\u003c/strong\u003e is a node that has zero children.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/16/example1drawio1.png\" style=\"width: 700px; height: 252px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [2,1,3,null,null,0,1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The above diagram illustrates the evaluation process.\nThe AND node evaluates to False AND True = False.\nThe OR node evaluates to True OR False = True.\nThe root node evaluates to True, so we return true.\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [0]\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The root node is a leaf node and it evaluates to false, so we return false.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 1000]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= Node.val \u0026lt;= 3\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eEvery node has either \u003ccode\u003e0\u003c/code\u003e or \u003ccode\u003e2\u003c/code\u003e children.\u003c/li\u003e\n\t\u003cli\u003eLeaf nodes have a value of \u003ccode\u003e0\u003c/code\u003e or \u003ccode\u003e1\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003eNon-leaf nodes have a value of \u003ccode\u003e2\u003c/code\u003e or \u003ccode\u003e3\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": ["Tree", "Depth-First Search", "Binary Tree"]
    },
    {
      "title": "Correct a Binary Tree",
      "titleSlug": "correct-a-binary-tree",
      "difficulty": "Medium",
      "content": "",
      "tags": [
        "Hash Table",
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ]
    },
    {
      "title": "Cousins in Binary Tree",
      "titleSlug": "cousins-in-binary-tree",
      "difficulty": "Easy",
      "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a binary tree with unique values and the values of two different nodes of the tree \u003ccode\u003ex\u003c/code\u003e and \u003ccode\u003ey\u003c/code\u003e, return \u003ccode\u003etrue\u003c/code\u003e \u003cem\u003eif the nodes corresponding to the values \u003c/em\u003e\u003ccode\u003ex\u003c/code\u003e\u003cem\u003e and \u003c/em\u003e\u003ccode\u003ey\u003c/code\u003e\u003cem\u003e in the tree are \u003cstrong\u003ecousins\u003c/strong\u003e, or \u003c/em\u003e\u003ccode\u003efalse\u003c/code\u003e\u003cem\u003e otherwise.\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003eTwo nodes of a binary tree are \u003cstrong\u003ecousins\u003c/strong\u003e if they have the same depth with different parents.\u003c/p\u003e\n\n\u003cp\u003eNote that in a binary tree, the root node is at the depth \u003ccode\u003e0\u003c/code\u003e, and children of each depth \u003ccode\u003ek\u003c/code\u003e node are at the depth \u003ccode\u003ek + 1\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/02/12/q1248-01.png\" style=\"width: 304px; height: 270px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2,3,4], x = 4, y = 3\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/02/12/q1248-02.png\" style=\"width: 334px; height: 266px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2,3,null,4,null,5], x = 5, y = 4\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/02/13/q1248-03.png\" style=\"width: 267px; height: 258px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2,3,null,4], x = 2, y = 3\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[2, 100]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= Node.val \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eEach node has a \u003cstrong\u003eunique\u003c/strong\u003e value.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ex != y\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ex\u003c/code\u003e and \u003ccode\u003ey\u003c/code\u003e are exist in the tree.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ]
    },
    {
      "title": "Maximum Binary Tree II",
      "titleSlug": "maximum-binary-tree-ii",
      "difficulty": "Medium",
      "content": "\u003cp\u003eA \u003cstrong\u003emaximum tree\u003c/strong\u003e is a tree where every node has a value greater than any other value in its subtree.\u003c/p\u003e\n\n\u003cp\u003eYou are given the \u003ccode\u003eroot\u003c/code\u003e of a maximum binary tree and an integer \u003ccode\u003eval\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eJust as in the \u003ca href=\"https://leetcode.com/problems/maximum-binary-tree/\" target=\"_blank\"\u003eprevious problem\u003c/a\u003e, the given tree was constructed from a list \u003ccode\u003ea\u003c/code\u003e (\u003ccode\u003eroot = Construct(a)\u003c/code\u003e) recursively with the following \u003ccode\u003eConstruct(a)\u003c/code\u003e routine:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eIf \u003ccode\u003ea\u003c/code\u003e is empty, return \u003ccode\u003enull\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003eOtherwise, let \u003ccode\u003ea[i]\u003c/code\u003e be the largest element of \u003ccode\u003ea\u003c/code\u003e. Create a \u003ccode\u003eroot\u003c/code\u003e node with the value \u003ccode\u003ea[i]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003eThe left child of \u003ccode\u003eroot\u003c/code\u003e will be \u003ccode\u003eConstruct([a[0], a[1], ..., a[i - 1]])\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003eThe right child of \u003ccode\u003eroot\u003c/code\u003e will be \u003ccode\u003eConstruct([a[i + 1], a[i + 2], ..., a[a.length - 1]])\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003eReturn \u003ccode\u003eroot\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eNote that we were not given \u003ccode\u003ea\u003c/code\u003e directly, only a root node \u003ccode\u003eroot = Construct(a)\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eSuppose \u003ccode\u003eb\u003c/code\u003e is a copy of \u003ccode\u003ea\u003c/code\u003e with the value \u003ccode\u003eval\u003c/code\u003e appended to it. It is guaranteed that \u003ccode\u003eb\u003c/code\u003e has unique values.\u003c/p\u003e\n\n\u003cp\u003eReturn \u003ccode\u003eConstruct(b)\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/09/maxtree1.JPG\" style=\"width: 376px; height: 235px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [4,1,3,null,null,2], val = 5\n\u003cstrong\u003eOutput:\u003c/strong\u003e [5,4,null,1,3,null,null,2]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e a = [1,4,2,3], b = [1,4,2,3,5]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/09/maxtree21.JPG\" style=\"width: 358px; height: 156px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [5,2,4,null,1], val = 3\n\u003cstrong\u003eOutput:\u003c/strong\u003e [5,2,4,null,1,null,3]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e a = [2,1,5,4], b = [2,1,5,4,3]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/09/maxtree3.JPG\" style=\"width: 404px; height: 180px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [5,2,3,null,1], val = 4\n\u003cstrong\u003eOutput:\u003c/strong\u003e [5,2,4,null,1,3]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e a = [2,1,5,3], b = [2,1,5,3,4]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 100]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= Node.val \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eAll the values of the tree are \u003cstrong\u003eunique\u003c/strong\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= val \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": ["Tree", "Binary Tree"]
    },
    {
      "title": "Binary Tree Coloring Game",
      "titleSlug": "binary-tree-coloring-game",
      "difficulty": "Medium",
      "content": "\u003cp\u003eTwo players play a turn based game on a binary tree. We are given the \u003ccode\u003eroot\u003c/code\u003e of this binary tree, and the number of nodes \u003ccode\u003en\u003c/code\u003e in the tree. \u003ccode\u003en\u003c/code\u003e is odd, and each node has a distinct value from \u003ccode\u003e1\u003c/code\u003e to \u003ccode\u003en\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eInitially, the first player names a value \u003ccode\u003ex\u003c/code\u003e with \u003ccode\u003e1 \u0026lt;= x \u0026lt;= n\u003c/code\u003e, and the second player names a value \u003ccode\u003ey\u003c/code\u003e with \u003ccode\u003e1 \u0026lt;= y \u0026lt;= n\u003c/code\u003e and \u003ccode\u003ey != x\u003c/code\u003e. The first player colors the node with value \u003ccode\u003ex\u003c/code\u003e red, and the second player colors the node with value \u003ccode\u003ey\u003c/code\u003e blue.\u003c/p\u003e\n\n\u003cp\u003eThen, the players take turns starting with the first player. In each turn, that player chooses a node of their color (red if player 1, blue if player 2) and colors an \u003cstrong\u003euncolored\u003c/strong\u003e neighbor of the chosen node (either the left child, right child, or parent of the chosen node.)\u003c/p\u003e\n\n\u003cp\u003eIf (and only if) a player cannot choose such a node in this way, they must pass their turn. If both players pass their turn, the game ends, and the winner is the player that colored more nodes.\u003c/p\u003e\n\n\u003cp\u003eYou are the second player. If it is possible to choose such a \u003ccode\u003ey\u003c/code\u003e to ensure you win the game, return \u003ccode\u003etrue\u003c/code\u003e. If it is not possible, return \u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/08/01/1480-binary-tree-coloring-game.png\" style=\"width: 500px; height: 310px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2,3,4,5,6,7,8,9,10,11], n = 11, x = 3\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003cstrong\u003eExplanation: \u003c/strong\u003eThe second player can choose the node with value 2.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2,3], n = 3, x = 1\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is \u003ccode\u003en\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= x \u0026lt;= n \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003en\u003c/code\u003e is odd.\u003c/li\u003e\n\t\u003cli\u003e1 \u0026lt;= Node.val \u0026lt;= n\u003c/li\u003e\n\t\u003cli\u003eAll the values of the tree are \u003cstrong\u003eunique\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": ["Tree", "Depth-First Search", "Binary Tree"]
    },
    {
      "title": "Validate Binary Tree Nodes",
      "titleSlug": "validate-binary-tree-nodes",
      "difficulty": "Medium",
      "content": "\u003cp\u003eYou have \u003ccode\u003en\u003c/code\u003e binary tree nodes numbered from \u003ccode\u003e0\u003c/code\u003e to \u003ccode\u003en - 1\u003c/code\u003e where node \u003ccode\u003ei\u003c/code\u003e has two children \u003ccode\u003eleftChild[i]\u003c/code\u003e and \u003ccode\u003erightChild[i]\u003c/code\u003e, return \u003ccode\u003etrue\u003c/code\u003e if and only if \u003cstrong\u003eall\u003c/strong\u003e the given nodes form \u003cstrong\u003eexactly one\u003c/strong\u003e valid binary tree.\u003c/p\u003e\n\n\u003cp\u003eIf node \u003ccode\u003ei\u003c/code\u003e has no left child then \u003ccode\u003eleftChild[i]\u003c/code\u003e will equal \u003ccode\u003e-1\u003c/code\u003e, similarly for the right child.\u003c/p\u003e\n\n\u003cp\u003eNote that the nodes have no values and that we only use the node numbers in this problem.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/08/23/1503_ex1.png\" style=\"width: 195px; height: 287px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 4, leftChild = [1,-1,3,-1], rightChild = [2,-1,-1,-1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/08/23/1503_ex2.png\" style=\"width: 183px; height: 272px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 4, leftChild = [1,-1,3,-1], rightChild = [2,3,-1,-1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/08/23/1503_ex3.png\" style=\"width: 82px; height: 174px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 2, leftChild = [1,0], rightChild = [-1,-1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003en == leftChild.length == rightChild.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-1 \u0026lt;= leftChild[i], rightChild[i] \u0026lt;= n - 1\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Union Find",
        "Graph",
        "Binary Tree"
      ]
    },
    {
      "title": "Diameter of Binary Tree",
      "titleSlug": "diameter-of-binary-tree",
      "difficulty": "Easy",
      "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a binary tree, return \u003cem\u003ethe length of the \u003cstrong\u003ediameter\u003c/strong\u003e of the tree\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe \u003cstrong\u003ediameter\u003c/strong\u003e of a binary tree is the \u003cstrong\u003elength\u003c/strong\u003e of the longest path between any two nodes in a tree. This path may or may not pass through the \u003ccode\u003eroot\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe \u003cstrong\u003elength\u003c/strong\u003e of a path between two nodes is represented by the number of edges between them.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg\" style=\"width: 292px; height: 302px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2,3,4,5]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 3\n\u003cstrong\u003eExplanation:\u003c/strong\u003e 3 is the length of the path [4,2,1,3] or [5,2,1,3].\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 1\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-100 \u0026lt;= Node.val \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": ["Tree", "Depth-First Search", "Binary Tree"]
    },
    {
      "title": "Boundary of Binary Tree",
      "titleSlug": "boundary-of-binary-tree",
      "difficulty": "Medium",
      "content": "",
      "tags": ["Tree", "Depth-First Search", "Binary Tree"]
    },
    {
      "title": "Complete Binary Tree Inserter",
      "titleSlug": "complete-binary-tree-inserter",
      "difficulty": "Medium",
      "content": "\u003cp\u003eA \u003cstrong\u003ecomplete binary tree\u003c/strong\u003e is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible.\u003c/p\u003e\n\n\u003cp\u003eDesign an algorithm to insert a new node to a complete binary tree keeping it complete after the insertion.\u003c/p\u003e\n\n\u003cp\u003eImplement the \u003ccode\u003eCBTInserter\u003c/code\u003e class:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003eCBTInserter(TreeNode root)\u003c/code\u003e Initializes the data structure with the \u003ccode\u003eroot\u003c/code\u003e of the complete binary tree.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eint insert(int v)\u003c/code\u003e Inserts a \u003ccode\u003eTreeNode\u003c/code\u003e into the tree with value \u003ccode\u003eNode.val == val\u003c/code\u003e so that the tree remains complete, and returns the value of the parent of the inserted \u003ccode\u003eTreeNode\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eTreeNode get_root()\u003c/code\u003e Returns the root node of the tree.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/03/lc-treeinsert.jpg\" style=\"width: 500px; height: 143px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput\u003c/strong\u003e\n[\u0026quot;CBTInserter\u0026quot;, \u0026quot;insert\u0026quot;, \u0026quot;insert\u0026quot;, \u0026quot;get_root\u0026quot;]\n[[[1, 2]], [3], [4], []]\n\u003cstrong\u003eOutput\u003c/strong\u003e\n[null, 1, 2, [1, 2, 3, 4]]\n\n\u003cstrong\u003eExplanation\u003c/strong\u003e\nCBTInserter cBTInserter = new CBTInserter([1, 2]);\ncBTInserter.insert(3);  // return 1\ncBTInserter.insert(4);  // return 2\ncBTInserter.get_root(); // return [1, 2, 3, 4]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree will be in the range \u003ccode\u003e[1, 1000]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= Node.val \u0026lt;= 5000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eroot\u003c/code\u003e is a complete binary tree.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= val \u0026lt;= 5000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eAt most \u003ccode\u003e10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e calls will be made to \u003ccode\u003einsert\u003c/code\u003e and \u003ccode\u003eget_root\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": ["Tree", "Breadth-First Search", "Design", "Binary Tree"]
    },
    {
      "title": "Binary Tree Level Order Traversal",
      "titleSlug": "binary-tree-level-order-traversal",
      "difficulty": "Medium",
      "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a binary tree, return \u003cem\u003ethe level order traversal of its nodes\u0026#39; values\u003c/em\u003e. (i.e., from left to right, level by level).\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg\" style=\"width: 277px; height: 302px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [3,9,20,null,null,15,7]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [[3],[9,20],[15,7]]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [[1]]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = []\n\u003cstrong\u003eOutput:\u003c/strong\u003e []\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[0, 2000]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-1000 \u0026lt;= Node.val \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": ["Tree", "Breadth-First Search", "Binary Tree"]
    },
    {
      "title": "Maximum Depth of Binary Tree",
      "titleSlug": "maximum-depth-of-binary-tree",
      "difficulty": "Easy",
      "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a binary tree, return \u003cem\u003eits maximum depth\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eA binary tree\u0026#39;s \u003cstrong\u003emaximum depth\u003c/strong\u003e\u0026nbsp;is the number of nodes along the longest path from the root node down to the farthest leaf node.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg\" style=\"width: 400px; height: 277px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [3,9,20,null,null,15,7]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 3\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,null,2]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[0, 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-100 \u0026lt;= Node.val \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ]
    },
    {
      "title": "Minimum Depth of Binary Tree",
      "titleSlug": "minimum-depth-of-binary-tree",
      "difficulty": "Easy",
      "content": "\u003cp\u003eGiven a binary tree, find its minimum depth.\u003c/p\u003e\n\n\u003cp\u003eThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e\u0026nbsp;A leaf is a node with no children.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg\" style=\"width: 432px; height: 302px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [3,9,20,null,null,15,7]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [2,null,3,null,4,null,5,null,6]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 5\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[0, 10\u003csup\u003e5\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-1000 \u0026lt;= Node.val \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ]
    },
    {
      "title": "Binary Tree Maximum Path Sum",
      "titleSlug": "binary-tree-maximum-path-sum",
      "difficulty": "Hard",
      "content": "\u003cp\u003eA \u003cstrong\u003epath\u003c/strong\u003e in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence \u003cstrong\u003eat most once\u003c/strong\u003e. Note that the path does not need to pass through the root.\u003c/p\u003e\n\n\u003cp\u003eThe \u003cstrong\u003epath sum\u003c/strong\u003e of a path is the sum of the node\u0026#39;s values in the path.\u003c/p\u003e\n\n\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a binary tree, return \u003cem\u003ethe maximum \u003cstrong\u003epath sum\u003c/strong\u003e of any \u003cstrong\u003enon-empty\u003c/strong\u003e path\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg\" style=\"width: 322px; height: 182px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2,3]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 6\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The optimal path is 2 -\u0026gt; 1 -\u0026gt; 3 with a path sum of 2 + 1 + 3 = 6.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [-10,9,20,null,null,15,7]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 42\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The optimal path is 15 -\u0026gt; 20 -\u0026gt; 7 with a path sum of 15 + 20 + 7 = 42.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 3 * 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-1000 \u0026lt;= Node.val \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": [
        "Dynamic Programming",
        "Tree",
        "Depth-First Search",
        "Binary Tree"
      ]
    },
    {
      "title": "Binary Tree Right Side View",
      "titleSlug": "binary-tree-right-side-view",
      "difficulty": "Medium",
      "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a binary tree, imagine yourself standing on the \u003cstrong\u003eright side\u003c/strong\u003e of it, return \u003cem\u003ethe values of the nodes you can see ordered from top to bottom\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cdiv class=\"example-block\"\u003e\n\u003cp\u003e\u003cstrong\u003eInput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003eroot = [1,2,3,null,5,null,4]\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eOutput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003e[1,3,4]\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eExplanation:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/11/24/tmpd5jn43fs-1.png\" style=\"width: 400px; height: 207px;\" /\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cdiv class=\"example-block\"\u003e\n\u003cp\u003e\u003cstrong\u003eInput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003eroot = [1,2,3,4,null,null,null,5]\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eOutput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003e[1,3,4,5]\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eExplanation:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/11/24/tmpkpe40xeh-1.png\" style=\"width: 400px; height: 214px;\" /\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cdiv class=\"example-block\"\u003e\n\u003cp\u003e\u003cstrong\u003eInput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003eroot = [1,null,3]\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eOutput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003e[1,3]\u003c/span\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 4:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cdiv class=\"example-block\"\u003e\n\u003cp\u003e\u003cstrong\u003eInput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003eroot = []\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eOutput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003e[]\u003c/span\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[0, 100]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-100 \u0026lt;= Node.val \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ]
    },
    {
      "title": "Serialize and Deserialize Binary Tree",
      "titleSlug": "serialize-and-deserialize-binary-tree",
      "difficulty": "Hard",
      "content": "\u003cp\u003eSerialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\u003c/p\u003e\n\n\u003cp\u003eDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eClarification:\u003c/strong\u003e The input/output format is the same as \u003ca href=\"https://support.leetcode.com/hc/en-us/articles/32442719377939-How-to-create-test-cases-on-LeetCode#h_01J5EGREAW3NAEJ14XC07GRW1A\" target=\"_blank\"\u003ehow LeetCode serializes a binary tree\u003c/a\u003e. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg\" style=\"width: 442px; height: 324px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2,3,null,null,4,5]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,2,3,null,null,4,5]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = []\n\u003cstrong\u003eOutput:\u003c/strong\u003e []\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[0, 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-1000 \u0026lt;= Node.val \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": [
        "String",
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Design",
        "Binary Tree"
      ]
    },
    {
      "title": "Binary Tree Longest Consecutive Sequence",
      "titleSlug": "binary-tree-longest-consecutive-sequence",
      "difficulty": "Medium",
      "content": "",
      "tags": ["Tree", "Depth-First Search", "Binary Tree"]
    },
    {
      "title": "Binary Tree Vertical Order Traversal",
      "titleSlug": "binary-tree-vertical-order-traversal",
      "difficulty": "Medium",
      "content": "",
      "tags": [
        "Hash Table",
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Sorting",
        "Binary Tree"
      ]
    },
    {
      "title": "Find Leaves of Binary Tree",
      "titleSlug": "find-leaves-of-binary-tree",
      "difficulty": "Medium",
      "content": "",
      "tags": ["Tree", "Depth-First Search", "Binary Tree"]
    },
    {
      "title": "Create Binary Tree From Descriptions",
      "titleSlug": "create-binary-tree-from-descriptions",
      "difficulty": "Medium",
      "content": "\u003cp\u003eYou are given a 2D integer array \u003ccode\u003edescriptions\u003c/code\u003e where \u003ccode\u003edescriptions[i] = [parent\u003csub\u003ei\u003c/sub\u003e, child\u003csub\u003ei\u003c/sub\u003e, isLeft\u003csub\u003ei\u003c/sub\u003e]\u003c/code\u003e indicates that \u003ccode\u003eparent\u003csub\u003ei\u003c/sub\u003e\u003c/code\u003e is the \u003cstrong\u003eparent\u003c/strong\u003e of \u003ccode\u003echild\u003csub\u003ei\u003c/sub\u003e\u003c/code\u003e in a \u003cstrong\u003ebinary\u003c/strong\u003e tree of \u003cstrong\u003eunique\u003c/strong\u003e values. Furthermore,\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eIf \u003ccode\u003eisLeft\u003csub\u003ei\u003c/sub\u003e == 1\u003c/code\u003e, then \u003ccode\u003echild\u003csub\u003ei\u003c/sub\u003e\u003c/code\u003e is the left child of \u003ccode\u003eparent\u003csub\u003ei\u003c/sub\u003e\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003eIf \u003ccode\u003eisLeft\u003csub\u003ei\u003c/sub\u003e == 0\u003c/code\u003e, then \u003ccode\u003echild\u003csub\u003ei\u003c/sub\u003e\u003c/code\u003e is the right child of \u003ccode\u003eparent\u003csub\u003ei\u003c/sub\u003e\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eConstruct the binary tree described by \u003ccode\u003edescriptions\u003c/code\u003e and return \u003cem\u003eits \u003cstrong\u003eroot\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe test cases will be generated such that the binary tree is \u003cstrong\u003evalid\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/09/example1drawio.png\" style=\"width: 300px; height: 236px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e descriptions = [[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [50,20,80,15,17,19]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The root node is the node with value 50 since it has no parent.\nThe resulting binary tree is shown in the diagram.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/09/example2drawio.png\" style=\"width: 131px; height: 300px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e descriptions = [[1,2,1],[2,3,0],[3,4,1]]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,2,null,null,3,4]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The root node is the node with value 1 since it has no parent.\nThe resulting binary tree is shown in the diagram.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= descriptions.length \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003edescriptions[i].length == 3\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= parent\u003csub\u003ei\u003c/sub\u003e, child\u003csub\u003ei\u003c/sub\u003e \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= isLeft\u003csub\u003ei\u003c/sub\u003e \u0026lt;= 1\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eThe binary tree described by \u003ccode\u003edescriptions\u003c/code\u003e is valid.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": ["Array", "Hash Table", "Tree", "Binary Tree"]
    },
    {
      "title": "Distribute Coins in Binary Tree",
      "titleSlug": "distribute-coins-in-binary-tree",
      "difficulty": "Medium",
      "content": "\u003cp\u003eYou are given the \u003ccode\u003eroot\u003c/code\u003e of a binary tree with \u003ccode\u003en\u003c/code\u003e nodes where each \u003ccode\u003enode\u003c/code\u003e in the tree has \u003ccode\u003enode.val\u003c/code\u003e coins. There are \u003ccode\u003en\u003c/code\u003e coins in total throughout the whole tree.\u003c/p\u003e\n\n\u003cp\u003eIn one move, we may choose two adjacent nodes and move one coin from one node to another. A move may be from parent to child, or from child to parent.\u003c/p\u003e\n\n\u003cp\u003eReturn \u003cem\u003ethe \u003cstrong\u003eminimum\u003c/strong\u003e number of moves required to make every node have \u003cstrong\u003eexactly\u003c/strong\u003e one coin\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/18/tree1.png\" style=\"width: 250px; height: 236px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [3,0,0]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2\n\u003cstrong\u003eExplanation: \u003c/strong\u003eFrom the root of the tree, we move one coin to its left child, and one coin to its right child.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/18/tree2.png\" style=\"width: 250px; height: 236px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [0,3,0]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 3\n\u003cstrong\u003eExplanation: \u003c/strong\u003eFrom the left child of the root, we move two coins to the root [taking two moves]. Then, we move one coin from the root of the tree to the right child.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is \u003ccode\u003en\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= Node.val \u0026lt;= n\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eThe sum of all \u003ccode\u003eNode.val\u003c/code\u003e is \u003ccode\u003en\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": ["Tree", "Depth-First Search", "Binary Tree"]
    },
    {
      "title": "Linked List in Binary Tree",
      "titleSlug": "linked-list-in-binary-tree",
      "difficulty": "Medium",
      "content": "\u003cp\u003eGiven a binary tree \u003ccode\u003eroot\u003c/code\u003e and a\u0026nbsp;linked list with\u0026nbsp;\u003ccode\u003ehead\u003c/code\u003e\u0026nbsp;as the first node.\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003eReturn True if all the elements in the linked list starting from the \u003ccode\u003ehead\u003c/code\u003e correspond to some \u003cem\u003edownward path\u003c/em\u003e connected in the binary tree\u0026nbsp;otherwise return False.\u003c/p\u003e\n\n\u003cp\u003eIn this context downward path means a path that starts at some node and goes downwards.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/12/sample_1_1720.png\" style=\"width: 220px; height: 280px;\" /\u003e\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003cstrong\u003eExplanation:\u003c/strong\u003e Nodes in blue form a subpath in the binary Tree.  \n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/12/sample_2_1720.png\" style=\"width: 220px; height: 280px;\" /\u003e\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003cstrong\u003eExplanation:\u003c/strong\u003e There is no path in the binary tree that contains all the elements of the linked list from \u003ccode\u003ehead\u003c/code\u003e.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree will be in the range \u003ccode\u003e[1, 2500]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003eThe number of nodes in the list will be in the range \u003ccode\u003e[1, 100]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= Node.val\u0026nbsp;\u0026lt;= 100\u003c/code\u003e\u0026nbsp;for each node in the linked list and binary tree.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": ["Linked List", "Tree", "Depth-First Search", "Binary Tree"]
    },
    {
      "title": "Construct Binary Tree from String",
      "titleSlug": "construct-binary-tree-from-string",
      "difficulty": "Medium",
      "content": "",
      "tags": ["String", "Stack", "Tree", "Depth-First Search", "Binary Tree"]
    },
    {
      "title": "Construct String from Binary Tree",
      "titleSlug": "construct-string-from-binary-tree",
      "difficulty": "Medium",
      "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e node of a binary tree, your task is to create a string representation of the tree following a specific set of formatting rules. The representation should be based on a preorder traversal of the binary tree and must adhere to the following guidelines:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\n\t\u003cp\u003e\u003cstrong\u003eNode Representation\u003c/strong\u003e: Each node in the tree should be represented by its integer value.\u003c/p\u003e\n\t\u003c/li\u003e\n\t\u003cli\u003e\n\t\u003cp\u003e\u003cstrong\u003eParentheses for Children\u003c/strong\u003e: If a node has at least one child (either left or right), its children should be represented inside parentheses. Specifically:\u003c/p\u003e\n\n\t\u003cul\u003e\n\t\t\u003cli\u003eIf a node has a left child, the value of the left child should be enclosed in parentheses immediately following the node\u0026#39;s value.\u003c/li\u003e\n\t\t\u003cli\u003eIf a node has a right child, the value of the right child should also be enclosed in parentheses. The parentheses for the right child should follow those of the left child.\u003c/li\u003e\n\t\u003c/ul\u003e\n\t\u003c/li\u003e\n\t\u003cli\u003e\n\t\u003cp\u003e\u003cstrong\u003eOmitting Empty Parentheses\u003c/strong\u003e: Any empty parentheses pairs (i.e., \u003ccode\u003e()\u003c/code\u003e) should be omitted from the final string representation of the tree, with one specific exception: when a node has a right child but no left child. In such cases, you must include an empty pair of parentheses to indicate the absence of the left child. This ensures that the one-to-one mapping between the string representation and the original binary tree structure is maintained.\u003c/p\u003e\n\n\t\u003cp\u003eIn summary, empty parentheses pairs should be omitted when a node has only a left child or no children. However, when a node has a right child but no left child, an empty pair of parentheses must precede the representation of the right child to reflect the tree\u0026#39;s structure accurately.\u003c/p\u003e\n\t\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/cons1-tree.jpg\" style=\"padding: 10px; background: #fff; border-radius: .5rem;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2,3,4]\n\u003cstrong\u003eOutput:\u003c/strong\u003e \u0026quot;1(2(4))(3)\u0026quot;\n\u003cstrong\u003eExplanation:\u003c/strong\u003e Originally, it needs to be \u0026quot;1(2(4)())(3()())\u0026quot;, but you need to omit all the empty parenthesis pairs. And it will be \u0026quot;1(2(4))(3)\u0026quot;.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/cons2-tree.jpg\" style=\"padding: 10px; background: #fff; border-radius: .5rem;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2,3,null,4]\n\u003cstrong\u003eOutput:\u003c/strong\u003e \u0026quot;1(2()(4))(3)\u0026quot;\n\u003cstrong\u003eExplanation:\u003c/strong\u003e Almost the same as the first example, except the \u003ccode\u003e()\u003c/code\u003e after \u003ccode\u003e2\u003c/code\u003e is necessary to indicate the absence of a left child for \u003ccode\u003e2\u003c/code\u003e and the presence of a right child.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-1000 \u0026lt;= Node.val \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": ["String", "Tree", "Depth-First Search", "Binary Tree"]
    },
    {
      "title": "Maximum Width of Binary Tree",
      "titleSlug": "maximum-width-of-binary-tree",
      "difficulty": "Medium",
      "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a binary tree, return \u003cem\u003ethe \u003cstrong\u003emaximum width\u003c/strong\u003e of the given tree\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe \u003cstrong\u003emaximum width\u003c/strong\u003e of a tree is the maximum \u003cstrong\u003ewidth\u003c/strong\u003e among all levels.\u003c/p\u003e\n\n\u003cp\u003eThe \u003cstrong\u003ewidth\u003c/strong\u003e of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes that would be present in a complete binary tree extending down to that level are also counted into the length calculation.\u003c/p\u003e\n\n\u003cp\u003eIt is \u003cstrong\u003eguaranteed\u003c/strong\u003e that the answer will in the range of a \u003cstrong\u003e32-bit\u003c/strong\u003e signed integer.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/width1-tree.jpg\" style=\"width: 359px; height: 302px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,3,2,5,3,null,9]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 4\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The maximum width exists in the third level with length 4 (5,3,null,9).\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/14/maximum-width-of-binary-tree-v3.jpg\" style=\"width: 442px; height: 422px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,3,2,5,null,null,9,6,null,7]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 7\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The maximum width exists in the fourth level with length 7 (6,null,null,null,null,null,7).\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/width3-tree.jpg\" style=\"width: 289px; height: 299px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,3,2,5]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The maximum width exists in the second level with length 2 (3,2).\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 3000]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-100 \u0026lt;= Node.val \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ]
    },
    {
      "title": "Cousins in Binary Tree II",
      "titleSlug": "cousins-in-binary-tree-ii",
      "difficulty": "Medium",
      "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a binary tree, replace the value of each node in the tree with the \u003cstrong\u003esum of all its cousins\u0026#39; values\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003eTwo nodes of a binary tree are \u003cstrong\u003ecousins\u003c/strong\u003e if they have the same depth with different parents.\u003c/p\u003e\n\n\u003cp\u003eReturn \u003cem\u003ethe \u003c/em\u003e\u003ccode\u003eroot\u003c/code\u003e\u003cem\u003e of the modified tree\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eNote\u003c/strong\u003e that the depth of a node is the number of edges in the path from the root node to it.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/11/example11.png\" style=\"width: 571px; height: 151px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [5,4,9,1,10,null,7]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [0,0,0,7,7,null,11]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The diagram above shows the initial binary tree and the binary tree after changing the value of each node.\n- Node with value 5 does not have any cousins so its sum is 0.\n- Node with value 4 does not have any cousins so its sum is 0.\n- Node with value 9 does not have any cousins so its sum is 0.\n- Node with value 1 has a cousin with value 7 so its sum is 7.\n- Node with value 10 has a cousin with value 7 so its sum is 7.\n- Node with value 7 has cousins with values 1 and 10 so its sum is 11.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/11/diagram33.png\" style=\"width: 481px; height: 91px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [3,1,2]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [0,0,0]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The diagram above shows the initial binary tree and the binary tree after changing the value of each node.\n- Node with value 3 does not have any cousins so its sum is 0.\n- Node with value 1 does not have any cousins so its sum is 0.\n- Node with value 2 does not have any cousins so its sum is 0.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 10\u003csup\u003e5\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= Node.val \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": [
        "Hash Table",
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ]
    },
    {
      "title": "Height of Special Binary Tree",
      "titleSlug": "height-of-special-binary-tree",
      "difficulty": "Medium",
      "content": "",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ]
    },
    {
      "title": "Binary Tree Zigzag Level Order Traversal",
      "titleSlug": "binary-tree-zigzag-level-order-traversal",
      "difficulty": "Medium",
      "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a binary tree, return \u003cem\u003ethe zigzag level order traversal of its nodes\u0026#39; values\u003c/em\u003e. (i.e., from left to right, then right to left for the next level and alternate between).\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg\" style=\"width: 277px; height: 302px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [3,9,20,null,null,15,7]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [[3],[20,9],[15,7]]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [[1]]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = []\n\u003cstrong\u003eOutput:\u003c/strong\u003e []\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[0, 2000]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-100 \u0026lt;= Node.val \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": ["Tree", "Breadth-First Search", "Binary Tree"]
    },
    {
      "title": "Binary Tree Level Order Traversal II",
      "titleSlug": "binary-tree-level-order-traversal-ii",
      "difficulty": "Medium",
      "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a binary tree, return \u003cem\u003ethe bottom-up level order traversal of its nodes\u0026#39; values\u003c/em\u003e. (i.e., from left to right, level by level from leaf to root).\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg\" style=\"width: 277px; height: 302px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [3,9,20,null,null,15,7]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [[15,7],[9,20],[3]]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [[1]]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = []\n\u003cstrong\u003eOutput:\u003c/strong\u003e []\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[0, 2000]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-1000 \u0026lt;= Node.val \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": ["Tree", "Breadth-First Search", "Binary Tree"]
    },
    {
      "title": "Flatten Binary Tree to Linked List",
      "titleSlug": "flatten-binary-tree-to-linked-list",
      "difficulty": "Medium",
      "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a binary tree, flatten the tree into a \u0026quot;linked list\u0026quot;:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe \u0026quot;linked list\u0026quot; should use the same \u003ccode\u003eTreeNode\u003c/code\u003e class where the \u003ccode\u003eright\u003c/code\u003e child pointer points to the next node in the list and the \u003ccode\u003eleft\u003c/code\u003e child pointer is always \u003ccode\u003enull\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003eThe \u0026quot;linked list\u0026quot; should be in the same order as a \u003ca href=\"https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR\" target=\"_blank\"\u003e\u003cstrong\u003epre-order\u003c/strong\u003e\u003cstrong\u003e traversal\u003c/strong\u003e\u003c/a\u003e of the binary tree.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg\" style=\"width: 500px; height: 226px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2,5,3,4,null,6]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,null,2,null,3,null,4,null,5,null,6]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = []\n\u003cstrong\u003eOutput:\u003c/strong\u003e []\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [0]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [0]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[0, 2000]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-100 \u0026lt;= Node.val \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cstrong\u003eFollow up:\u003c/strong\u003e Can you flatten the tree in-place (with \u003ccode\u003eO(1)\u003c/code\u003e extra space)?",
      "tags": [
        "Linked List",
        "Stack",
        "Tree",
        "Depth-First Search",
        "Binary Tree"
      ]
    },
    {
      "title": "Reverse Odd Levels of Binary Tree",
      "titleSlug": "reverse-odd-levels-of-binary-tree",
      "difficulty": "Medium",
      "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a \u003cstrong\u003eperfect\u003c/strong\u003e binary tree, reverse the node values at each \u003cstrong\u003eodd\u003c/strong\u003e level of the tree.\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eFor example, suppose the node values at level 3 are \u003ccode\u003e[2,1,3,4,7,11,29,18]\u003c/code\u003e, then it should become \u003ccode\u003e[18,29,11,7,4,3,1,2]\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eReturn \u003cem\u003ethe root of the reversed tree\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eA binary tree is \u003cstrong\u003eperfect\u003c/strong\u003e if all parent nodes have two children and all leaves are on the same level.\u003c/p\u003e\n\n\u003cp\u003eThe \u003cstrong\u003elevel\u003c/strong\u003e of a node is the number of edges along the path between it and the root node.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/07/28/first_case1.png\" style=\"width: 626px; height: 191px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [2,3,5,8,13,21,34]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [2,5,3,8,13,21,34]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e \nThe tree has only one odd level.\nThe nodes at level 1 are 3, 5 respectively, which are reversed and become 5, 3.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/07/28/second_case3.png\" style=\"width: 591px; height: 111px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [7,13,11]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [7,11,13]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e \nThe nodes at level 1 are 13, 11, which are reversed and become 11, 13.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [0,1,2,0,0,0,0,1,1,1,1,2,2,2,2]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [0,2,1,0,0,0,0,2,2,2,2,1,1,1,1]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e \nThe odd levels have non-zero values.\nThe nodes at level 1 were 1, 2, and are 2, 1 after the reversal.\nThe nodes at level 3 were 1, 1, 1, 1, 2, 2, 2, 2, and are 2, 2, 2, 2, 1, 1, 1, 1 after the reversal.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 2\u003csup\u003e14\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= Node.val \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eroot\u003c/code\u003e is a \u003cstrong\u003eperfect\u003c/strong\u003e binary tree.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ]
    },
    {
      "title": "Count Good Nodes in Binary Tree",
      "titleSlug": "count-good-nodes-in-binary-tree",
      "difficulty": "Medium",
      "content": "\u003cp\u003eGiven a binary tree \u003ccode\u003eroot\u003c/code\u003e, a node \u003cem\u003eX\u003c/em\u003e in the tree is named\u0026nbsp;\u003cstrong\u003egood\u003c/strong\u003e if in the path from root to \u003cem\u003eX\u003c/em\u003e there are no nodes with a value \u003cem\u003egreater than\u003c/em\u003e X.\u003c/p\u003e\r\n\r\n\u003cp\u003eReturn the number of \u003cstrong\u003egood\u003c/strong\u003e nodes in the binary tree.\u003c/p\u003e\r\n\r\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\r\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\r\n\r\n\u003cp\u003e\u003cstrong\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/04/02/test_sample_1.png\" style=\"width: 263px; height: 156px;\" /\u003e\u003c/strong\u003e\u003c/p\u003e\r\n\r\n\u003cpre\u003e\r\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [3,1,4,3,null,1,5]\r\n\u003cstrong\u003eOutput:\u003c/strong\u003e 4\r\n\u003cstrong\u003eExplanation:\u003c/strong\u003e Nodes in blue are \u003cstrong\u003egood\u003c/strong\u003e.\r\nRoot Node (3) is always a good node.\r\nNode 4 -\u0026gt; (3,4) is the maximum value in the path starting from the root.\r\nNode 5 -\u0026gt; (3,4,5) is the maximum value in the path\r\nNode 3 -\u0026gt; (3,1,3) is the maximum value in the path.\u003c/pre\u003e\r\n\r\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\r\n\r\n\u003cp\u003e\u003cstrong\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/04/02/test_sample_2.png\" style=\"width: 157px; height: 161px;\" /\u003e\u003c/strong\u003e\u003c/p\u003e\r\n\r\n\u003cpre\u003e\r\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [3,3,null,4,2]\r\n\u003cstrong\u003eOutput:\u003c/strong\u003e 3\r\n\u003cstrong\u003eExplanation:\u003c/strong\u003e Node 2 -\u0026gt; (3, 3, 2) is not good, because \u0026quot;3\u0026quot; is higher than it.\u003c/pre\u003e\r\n\r\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\r\n\r\n\u003cpre\u003e\r\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1]\r\n\u003cstrong\u003eOutput:\u003c/strong\u003e 1\r\n\u003cstrong\u003eExplanation:\u003c/strong\u003e Root is considered as \u003cstrong\u003egood\u003c/strong\u003e.\u003c/pre\u003e\r\n\r\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\r\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\r\n\r\n\u003cul\u003e\r\n\t\u003cli\u003eThe number of nodes in the binary tree is in the range\u0026nbsp;\u003ccode\u003e[1, 10^5]\u003c/code\u003e.\u003c/li\u003e\r\n\t\u003cli\u003eEach node\u0026#39;s value is between \u003ccode\u003e[-10^4, 10^4]\u003c/code\u003e.\u003c/li\u003e\r\n\u003c/ul\u003e",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ]
    },
    {
      "title": "Clone Binary Tree With Random Pointer",
      "titleSlug": "clone-binary-tree-with-random-pointer",
      "difficulty": "Medium",
      "content": "",
      "tags": [
        "Hash Table",
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ]
    },
    {
      "title": "Find Distance in a Binary Tree",
      "titleSlug": "find-distance-in-a-binary-tree",
      "difficulty": "Medium",
      "content": "",
      "tags": [
        "Hash Table",
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ]
    },
    {
      "title": "Path In Zigzag Labelled Binary Tree",
      "titleSlug": "path-in-zigzag-labelled-binary-tree",
      "difficulty": "Medium",
      "content": "\u003cp\u003eIn an infinite binary tree where every node has two children, the nodes are labelled in row order.\u003c/p\u003e\n\n\u003cp\u003eIn the odd numbered rows (ie., the first, third, fifth,...), the labelling is left to right, while in the even numbered rows (second, fourth, sixth,...), the labelling is right to left.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/06/24/tree.png\" style=\"width: 300px; height: 138px;\" /\u003e\u003c/p\u003e\n\n\u003cp\u003eGiven the \u003ccode\u003elabel\u003c/code\u003e of a node in this tree, return the labels in the path from the root of the tree to the\u0026nbsp;node with that \u003ccode\u003elabel\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e label = 14\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,3,4,14]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e label = 26\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,2,6,10,26]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= label \u0026lt;= 10^6\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": ["Math", "Tree", "Binary Tree"]
    },
    {
      "title": "Maximum Product of Splitted Binary Tree",
      "titleSlug": "maximum-product-of-splitted-binary-tree",
      "difficulty": "Medium",
      "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a binary tree, split the binary tree into two subtrees by removing one edge such that the product of the sums of the subtrees is maximized.\u003c/p\u003e\n\n\u003cp\u003eReturn \u003cem\u003ethe maximum product of the sums of the two subtrees\u003c/em\u003e. Since the answer may be too large, return it \u003cstrong\u003emodulo\u003c/strong\u003e \u003ccode\u003e10\u003csup\u003e9\u003c/sup\u003e + 7\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eNote\u003c/strong\u003e that you need to maximize the answer before taking the mod and not after taking it.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/01/21/sample_1_1699.png\" style=\"width: 500px; height: 167px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2,3,4,5,6]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 110\n\u003cstrong\u003eExplanation:\u003c/strong\u003e Remove the red edge and get 2 binary trees with sum 11 and 10. Their product is 110 (11*10)\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/01/21/sample_2_1699.png\" style=\"width: 500px; height: 211px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,null,2,3,4,null,null,5,6]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 90\n\u003cstrong\u003eExplanation:\u003c/strong\u003e Remove the red edge and get 2 binary trees with sum 15 and 6.Their product is 90 (15*6)\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[2, 5 * 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= Node.val \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": ["Tree", "Depth-First Search", "Binary Tree"]
    },
    {
      "title": "Maximum Sum BST in Binary Tree",
      "titleSlug": "maximum-sum-bst-in-binary-tree",
      "difficulty": "Hard",
      "content": "\u003cp\u003eGiven a \u003cstrong\u003ebinary tree\u003c/strong\u003e \u003ccode\u003eroot\u003c/code\u003e, return \u003cem\u003ethe maximum sum of all keys of \u003cstrong\u003eany\u003c/strong\u003e sub-tree which is also a Binary Search Tree (BST)\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eAssume a BST is defined as follows:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe left subtree of a node contains only nodes with keys \u003cstrong\u003eless than\u003c/strong\u003e the node\u0026#39;s key.\u003c/li\u003e\n\t\u003cli\u003eThe right subtree of a node contains only nodes with keys \u003cstrong\u003egreater than\u003c/strong\u003e the node\u0026#39;s key.\u003c/li\u003e\n\t\u003cli\u003eBoth the left and right subtrees must also be binary search trees.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/01/30/sample_1_1709.png\" style=\"width: 320px; height: 250px;\" /\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 20\n\u003cstrong\u003eExplanation:\u003c/strong\u003e Maximum sum in a valid Binary search tree is obtained in root node with key equal to 3.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/01/30/sample_2_1709.png\" style=\"width: 134px; height: 180px;\" /\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [4,3,null,1,2]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2\n\u003cstrong\u003eExplanation:\u003c/strong\u003e Maximum sum in a valid Binary search tree is obtained in a single root node with key equal to 2.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [-4,-2,-5]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 0\n\u003cstrong\u003eExplanation:\u003c/strong\u003e All values are negatives. Return an empty BST.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 4 * 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-4 * 10\u003csup\u003e4\u003c/sup\u003e \u0026lt;= Node.val \u0026lt;= 4 * 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": [
        "Dynamic Programming",
        "Tree",
        "Depth-First Search",
        "Binary Search Tree",
        "Binary Tree"
      ]
    },
    {
      "title": "Binary Tree Longest Consecutive Sequence II",
      "titleSlug": "binary-tree-longest-consecutive-sequence-ii",
      "difficulty": "Medium",
      "content": "",
      "tags": ["Tree", "Depth-First Search", "Binary Tree"]
    },
    {
      "title": "Average of Levels in Binary Tree",
      "titleSlug": "average-of-levels-in-binary-tree",
      "difficulty": "Easy",
      "content": "Given the \u003ccode\u003eroot\u003c/code\u003e of a binary tree, return \u003cem\u003ethe average value of the nodes on each level in the form of an array\u003c/em\u003e. Answers within \u003ccode\u003e10\u003csup\u003e-5\u003c/sup\u003e\u003c/code\u003e of the actual answer will be accepted.\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/09/avg1-tree.jpg\" style=\"width: 277px; height: 302px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [3,9,20,null,null,15,7]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [3.00000,14.50000,11.00000]\nExplanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.\nHence return [3, 14.5, 11].\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/09/avg2-tree.jpg\" style=\"width: 292px; height: 302px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [3,9,20,15,7]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [3.00000,14.50000,11.00000]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-2\u003csup\u003e31\u003c/sup\u003e \u0026lt;= Node.val \u0026lt;= 2\u003csup\u003e31\u003c/sup\u003e - 1\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ]
    },
    {
      "title": "Closest Leaf in a Binary Tree",
      "titleSlug": "closest-leaf-in-a-binary-tree",
      "difficulty": "Medium",
      "content": "",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ]
    },
    {
      "title": "Encode N-ary Tree to Binary Tree",
      "titleSlug": "encode-n-ary-tree-to-binary-tree",
      "difficulty": "Hard",
      "content": "",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Design",
        "Binary Tree"
      ]
    },
    {
      "title": "Check Completeness of a Binary Tree",
      "titleSlug": "check-completeness-of-a-binary-tree",
      "difficulty": "Medium",
      "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a binary tree, determine if it is a \u003cem\u003ecomplete binary tree\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eIn a \u003cstrong\u003e\u003ca href=\"http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees\" target=\"_blank\"\u003ecomplete binary tree\u003c/a\u003e\u003c/strong\u003e, every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between \u003ccode\u003e1\u003c/code\u003e and \u003ccode\u003e2\u003csup\u003eh\u003c/sup\u003e\u003c/code\u003e nodes inclusive at the last level \u003ccode\u003eh\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/15/complete-binary-tree-1.png\" style=\"width: 180px; height: 145px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2,3,4,5,6]\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003cstrong\u003eExplanation:\u003c/strong\u003e Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/15/complete-binary-tree-2.png\" style=\"width: 200px; height: 145px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2,3,4,5,null,7]\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The node with value 7 isn\u0026#39;t as far left as possible.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 100]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= Node.val \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": ["Tree", "Breadth-First Search", "Binary Tree"]
    },
    {
      "title": "Lowest Common Ancestor of a Binary Tree",
      "titleSlug": "lowest-common-ancestor-of-a-binary-tree",
      "difficulty": "Medium",
      "content": "\u003cp\u003eGiven a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\u003c/p\u003e\n\n\u003cp\u003eAccording to the \u003ca href=\"https://en.wikipedia.org/wiki/Lowest_common_ancestor\" target=\"_blank\"\u003edefinition of LCA on Wikipedia\u003c/a\u003e: \u0026ldquo;The lowest common ancestor is defined between two nodes \u003ccode\u003ep\u003c/code\u003e and \u003ccode\u003eq\u003c/code\u003e as the lowest node in \u003ccode\u003eT\u003c/code\u003e that has both \u003ccode\u003ep\u003c/code\u003e and \u003ccode\u003eq\u003c/code\u003e as descendants (where we allow \u003cb\u003ea node to be a descendant of itself\u003c/b\u003e).\u0026rdquo;\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style=\"width: 200px; height: 190px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n\u003cstrong\u003eOutput:\u003c/strong\u003e 3\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The LCA of nodes 5 and 1 is 3.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style=\"width: 200px; height: 190px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n\u003cstrong\u003eOutput:\u003c/strong\u003e 5\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2], p = 1, q = 2\n\u003cstrong\u003eOutput:\u003c/strong\u003e 1\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[2, 10\u003csup\u003e5\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e9\u003c/sup\u003e \u0026lt;= Node.val \u0026lt;= 10\u003csup\u003e9\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eAll \u003ccode\u003eNode.val\u003c/code\u003e are \u003cstrong\u003eunique\u003c/strong\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ep != q\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ep\u003c/code\u003e and \u003ccode\u003eq\u003c/code\u003e will exist in the tree.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": ["Tree", "Depth-First Search", "Binary Tree"]
    },
    {
      "title": "Verify Preorder Serialization of a Binary Tree",
      "titleSlug": "verify-preorder-serialization-of-a-binary-tree",
      "difficulty": "Medium",
      "content": "\u003cp\u003eOne way to serialize a binary tree is to use \u003cstrong\u003epreorder traversal\u003c/strong\u003e. When we encounter a non-null node, we record the node\u0026#39;s value. If it is a null node, we record using a sentinel value such as \u003ccode\u003e\u0026#39;#\u0026#39;\u003c/code\u003e.\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/12/pre-tree.jpg\" style=\"width: 362px; height: 293px;\" /\u003e\n\u003cp\u003eFor example, the above binary tree can be serialized to the string \u003ccode\u003e\u0026quot;9,3,4,#,#,1,#,#,2,#,6,#,#\u0026quot;\u003c/code\u003e, where \u003ccode\u003e\u0026#39;#\u0026#39;\u003c/code\u003e represents a null node.\u003c/p\u003e\n\n\u003cp\u003eGiven a string of comma-separated values \u003ccode\u003epreorder\u003c/code\u003e, return \u003ccode\u003etrue\u003c/code\u003e if it is a correct preorder traversal serialization of a binary tree.\u003c/p\u003e\n\n\u003cp\u003eIt is \u003cstrong\u003eguaranteed\u003c/strong\u003e that each comma-separated value in the string must be either an integer or a character \u003ccode\u003e\u0026#39;#\u0026#39;\u003c/code\u003e representing null pointer.\u003c/p\u003e\n\n\u003cp\u003eYou may assume that the input format is always valid.\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eFor example, it could never contain two consecutive commas, such as \u003ccode\u003e\u0026quot;1,,3\u0026quot;\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003cstrong\u003eNote:\u0026nbsp;\u003c/strong\u003eYou are not allowed to reconstruct the tree.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e preorder = \"9,3,4,#,#,1,#,#,2,#,6,#,#\"\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003c/pre\u003e\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e preorder = \"1,#\"\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003c/pre\u003e\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e preorder = \"9,#,#,1\"\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003c/pre\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= preorder.length \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003epreorder\u003c/code\u003e consist of integers in the range \u003ccode\u003e[0, 100]\u003c/code\u003e and \u003ccode\u003e\u0026#39;#\u0026#39;\u003c/code\u003e separated by commas \u003ccode\u003e\u0026#39;,\u0026#39;\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": ["String", "Stack", "Tree", "Binary Tree"]
    },
    {
      "title": "Pseudo-Palindromic Paths in a Binary Tree",
      "titleSlug": "pseudo-palindromic-paths-in-a-binary-tree",
      "difficulty": "Medium",
      "content": "\u003cp\u003eGiven a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be \u003cstrong\u003epseudo-palindromic\u003c/strong\u003e if at least one permutation of the node values in the path is a palindrome.\u003c/p\u003e\n\n\u003cp\u003e\u003cem\u003eReturn the number of \u003cstrong\u003epseudo-palindromic\u003c/strong\u003e paths going from the root node to leaf nodes.\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/05/06/palindromic_paths_1.png\" style=\"width: 300px; height: 201px;\" /\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [2,3,1,3,1,null,1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2 \n\u003cstrong\u003eExplanation:\u003c/strong\u003e The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the red path [2,3,3], the green path [2,1,1], and the path [2,3,1]. Among these paths only red path and green path are pseudo-palindromic paths since the red path [2,3,3] can be rearranged in [3,2,3] (palindrome) and the green path [2,1,1] can be rearranged in [1,2,1] (palindrome).\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/05/07/palindromic_paths_2.png\" style=\"width: 300px; height: 314px;\" /\u003e\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [2,1,1,1,3,null,null,null,null,null,1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 1 \n\u003cstrong\u003eExplanation:\u003c/strong\u003e The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the green path [2,1,1], the path [2,1,3,1], and the path [2,1]. Among these paths only the green path is pseudo-palindromic since [2,1,1] can be rearranged in [1,2,1] (palindrome).\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [9]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 1\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 10\u003csup\u003e5\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= Node.val \u0026lt;= 9\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": [
        "Bit Manipulation",
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ]
    },
    {
      "title": "Find Nearest Right Node in Binary Tree",
      "titleSlug": "find-nearest-right-node-in-binary-tree",
      "difficulty": "Medium",
      "content": "",
      "tags": ["Tree", "Breadth-First Search", "Binary Tree"]
    },
    {
      "title": "Change the Root of a Binary Tree",
      "titleSlug": "change-the-root-of-a-binary-tree",
      "difficulty": "Medium",
      "content": "",
      "tags": ["Tree", "Depth-First Search", "Binary Tree"]
    },
    {
      "title": "Flip Binary Tree To Match Preorder Traversal",
      "titleSlug": "flip-binary-tree-to-match-preorder-traversal",
      "difficulty": "Medium",
      "content": "\u003cp\u003eYou are given the \u003ccode\u003eroot\u003c/code\u003e of a binary tree with \u003ccode\u003en\u003c/code\u003e nodes, where each node is uniquely assigned a value from \u003ccode\u003e1\u003c/code\u003e to \u003ccode\u003en\u003c/code\u003e. You are also given a sequence of \u003ccode\u003en\u003c/code\u003e values \u003ccode\u003evoyage\u003c/code\u003e, which is the \u003cstrong\u003edesired\u003c/strong\u003e \u003ca href=\"https://en.wikipedia.org/wiki/Tree_traversal#Pre-order\" target=\"_blank\"\u003e\u003cstrong\u003epre-order traversal\u003c/strong\u003e\u003c/a\u003e of the binary tree.\u003c/p\u003e\n\n\u003cp\u003eAny node in the binary tree can be \u003cstrong\u003eflipped\u003c/strong\u003e by swapping its left and right subtrees. For example, flipping node 1 will have the following effect:\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/15/fliptree.jpg\" style=\"width: 400px; height: 187px;\" /\u003e\n\u003cp\u003eFlip the \u003cstrong\u003esmallest\u003c/strong\u003e number of nodes so that the \u003cstrong\u003epre-order traversal\u003c/strong\u003e of the tree \u003cstrong\u003ematches\u003c/strong\u003e \u003ccode\u003evoyage\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eReturn \u003cem\u003ea list of the values of all \u003cstrong\u003eflipped\u003c/strong\u003e nodes. You may return the answer in \u003cstrong\u003eany order\u003c/strong\u003e. If it is \u003cstrong\u003eimpossible\u003c/strong\u003e to flip the nodes in the tree to make the pre-order traversal match \u003c/em\u003e\u003ccode\u003evoyage\u003c/code\u003e\u003cem\u003e, return the list \u003c/em\u003e\u003ccode\u003e[-1]\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/02/1219-01.png\" style=\"width: 150px; height: 205px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2], voyage = [2,1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [-1]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e It is impossible to flip the nodes such that the pre-order traversal matches voyage.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/02/1219-02.png\" style=\"width: 150px; height: 142px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2,3], voyage = [1,3,2]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e Flipping node 1 swaps nodes 2 and 3, so the pre-order traversal matches voyage.\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/02/1219-02.png\" style=\"width: 150px; height: 142px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2,3], voyage = [1,2,3]\n\u003cstrong\u003eOutput:\u003c/strong\u003e []\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The tree\u0026#39;s pre-order traversal already matches voyage, so no nodes need to be flipped.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is \u003ccode\u003en\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003en == voyage.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= Node.val, voyage[i] \u0026lt;= n\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eAll the values in the tree are \u003cstrong\u003eunique\u003c/strong\u003e.\u003c/li\u003e\n\t\u003cli\u003eAll the values in \u003ccode\u003evoyage\u003c/code\u003e are \u003cstrong\u003eunique\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": ["Tree", "Depth-First Search", "Binary Tree"]
    },
    {
      "title": "Vertical Order Traversal of a Binary Tree",
      "titleSlug": "vertical-order-traversal-of-a-binary-tree",
      "difficulty": "Hard",
      "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a binary tree, calculate the \u003cstrong\u003evertical order traversal\u003c/strong\u003e of the binary tree.\u003c/p\u003e\n\n\u003cp\u003eFor each node at position \u003ccode\u003e(row, col)\u003c/code\u003e, its left and right children will be at positions \u003ccode\u003e(row + 1, col - 1)\u003c/code\u003e and \u003ccode\u003e(row + 1, col + 1)\u003c/code\u003e respectively. The root of the tree is at \u003ccode\u003e(0, 0)\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe \u003cstrong\u003evertical order traversal\u003c/strong\u003e of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values.\u003c/p\u003e\n\n\u003cp\u003eReturn \u003cem\u003ethe \u003cstrong\u003evertical order traversal\u003c/strong\u003e of the binary tree\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/29/vtree1.jpg\" style=\"width: 431px; height: 304px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [3,9,20,null,null,15,7]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [[9],[3,15],[20],[7]]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e\nColumn -1: Only node 9 is in this column.\nColumn 0: Nodes 3 and 15 are in this column in that order from top to bottom.\nColumn 1: Only node 20 is in this column.\nColumn 2: Only node 7 is in this column.\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/29/vtree2.jpg\" style=\"width: 512px; height: 304px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2,3,4,5,6,7]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [[4],[2],[1,5,6],[3],[7]]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e\nColumn -2: Only node 4 is in this column.\nColumn -1: Only node 2 is in this column.\nColumn 0: Nodes 1, 5, and 6 are in this column.\n          1 is at the top, so it comes first.\n          5 and 6 are at the same position (2, 0), so we order them by their value, 5 before 6.\nColumn 1: Only node 3 is in this column.\nColumn 2: Only node 7 is in this column.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/29/vtree3.jpg\" style=\"width: 512px; height: 304px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2,3,4,6,5,7]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [[4],[2],[1,5,6],[3],[7]]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e\nThis case is the exact same as example 2, but with nodes 5 and 6 swapped.\nNote that the solution remains the same since 5 and 6 are in the same location and should be ordered by their values.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 1000]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= Node.val \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": [
        "Hash Table",
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Sorting",
        "Binary Tree"
      ]
    },
    {
      "title": "Maximum Level Sum of a Binary Tree",
      "titleSlug": "maximum-level-sum-of-a-binary-tree",
      "difficulty": "Medium",
      "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a binary tree, the level of its root is \u003ccode\u003e1\u003c/code\u003e, the level of its children is \u003ccode\u003e2\u003c/code\u003e, and so on.\u003c/p\u003e\n\n\u003cp\u003eReturn the \u003cstrong\u003esmallest\u003c/strong\u003e level \u003ccode\u003ex\u003c/code\u003e such that the sum of all the values of nodes at level \u003ccode\u003ex\u003c/code\u003e is \u003cstrong\u003emaximal\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/05/03/capture.JPG\" style=\"width: 200px; height: 175px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,7,0,7,-8,null,null]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2\n\u003cstrong\u003eExplanation: \u003c/strong\u003e\nLevel 1 sum = 1.\nLevel 2 sum = 7 + 0 = 7.\nLevel 3 sum = 7 + -8 = -1.\nSo we return the level with the maximum sum which is level 2.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [989,null,10250,98693,-89388,null,null,null,-32127]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e5\u003c/sup\u003e \u0026lt;= Node.val \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ]
    },
    {
      "title": "Find Elements in a Contaminated Binary Tree",
      "titleSlug": "find-elements-in-a-contaminated-binary-tree",
      "difficulty": "Medium",
      "content": "\u003cp\u003eGiven a binary tree with the following rules:\u003c/p\u003e\n\n\u003col\u003e\n\t\u003cli\u003e\u003ccode\u003eroot.val == 0\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eFor any \u003ccode\u003etreeNode\u003c/code\u003e:\n\t\u003col type=\"a\"\u003e\n\t\t\u003cli\u003eIf \u003ccode\u003etreeNode.val\u003c/code\u003e has a value \u003ccode\u003ex\u003c/code\u003e and \u003ccode\u003etreeNode.left != null\u003c/code\u003e, then \u003ccode\u003etreeNode.left.val == 2 * x + 1\u003c/code\u003e\u003c/li\u003e\n\t\t\u003cli\u003eIf \u003ccode\u003etreeNode.val\u003c/code\u003e has a value \u003ccode\u003ex\u003c/code\u003e and \u003ccode\u003etreeNode.right != null\u003c/code\u003e, then \u003ccode\u003etreeNode.right.val == 2 * x + 2\u003c/code\u003e\u003c/li\u003e\n\t\u003c/ol\u003e\n\t\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eNow the binary tree is contaminated, which means all \u003ccode\u003etreeNode.val\u003c/code\u003e have been changed to \u003ccode\u003e-1\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eImplement the \u003ccode\u003eFindElements\u003c/code\u003e class:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003eFindElements(TreeNode* root)\u003c/code\u003e Initializes the object with a contaminated binary tree and recovers it.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ebool find(int target)\u003c/code\u003e Returns \u003ccode\u003etrue\u003c/code\u003e if the \u003ccode\u003etarget\u003c/code\u003e value exists in the recovered binary tree.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/06/untitled-diagram-4-1.jpg\" style=\"width: 320px; height: 119px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput\u003c/strong\u003e\n[\u0026quot;FindElements\u0026quot;,\u0026quot;find\u0026quot;,\u0026quot;find\u0026quot;]\n[[[-1,null,-1]],[1],[2]]\n\u003cstrong\u003eOutput\u003c/strong\u003e\n[null,false,true]\n\u003cstrong\u003eExplanation\u003c/strong\u003e\nFindElements findElements = new FindElements([-1,null,-1]); \nfindElements.find(1); // return False \nfindElements.find(2); // return True \u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/06/untitled-diagram-4.jpg\" style=\"width: 400px; height: 198px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput\u003c/strong\u003e\n[\u0026quot;FindElements\u0026quot;,\u0026quot;find\u0026quot;,\u0026quot;find\u0026quot;,\u0026quot;find\u0026quot;]\n[[[-1,-1,-1,-1,-1]],[1],[3],[5]]\n\u003cstrong\u003eOutput\u003c/strong\u003e\n[null,true,true,false]\n\u003cstrong\u003eExplanation\u003c/strong\u003e\nFindElements findElements = new FindElements([-1,-1,-1,-1,-1]);\nfindElements.find(1); // return True\nfindElements.find(3); // return True\nfindElements.find(5); // return False\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/07/untitled-diagram-4-1-1.jpg\" style=\"width: 306px; height: 274px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput\u003c/strong\u003e\n[\u0026quot;FindElements\u0026quot;,\u0026quot;find\u0026quot;,\u0026quot;find\u0026quot;,\u0026quot;find\u0026quot;,\u0026quot;find\u0026quot;]\n[[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]]\n\u003cstrong\u003eOutput\u003c/strong\u003e\n[null,true,false,false,true]\n\u003cstrong\u003eExplanation\u003c/strong\u003e\nFindElements findElements = new FindElements([-1,null,-1,-1,null,-1]);\nfindElements.find(2); // return True\nfindElements.find(3); // return False\nfindElements.find(4); // return False\nfindElements.find(5); // return True\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003eTreeNode.val == -1\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eThe height of the binary tree is less than or equal to \u003ccode\u003e20\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eThe total number of nodes is between \u003ccode\u003e[1, 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eTotal calls of \u003ccode\u003efind()\u003c/code\u003e is between \u003ccode\u003e[1, 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= target \u0026lt;= 10\u003csup\u003e6\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": [
        "Hash Table",
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Design",
        "Binary Tree"
      ]
    },
    {
      "title": "Longest ZigZag Path in a Binary Tree",
      "titleSlug": "longest-zigzag-path-in-a-binary-tree",
      "difficulty": "Medium",
      "content": "\u003cp\u003eYou are given the \u003ccode\u003eroot\u003c/code\u003e of a binary tree.\u003c/p\u003e\n\n\u003cp\u003eA ZigZag path for a binary tree is defined as follow:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eChoose \u003cstrong\u003eany \u003c/strong\u003enode in the binary tree and a direction (right or left).\u003c/li\u003e\n\t\u003cli\u003eIf the current direction is right, move to the right child of the current node; otherwise, move to the left child.\u003c/li\u003e\n\t\u003cli\u003eChange the direction from right to left or from left to right.\u003c/li\u003e\n\t\u003cli\u003eRepeat the second and third steps until you can\u0026#39;t move in the tree.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eZigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0).\u003c/p\u003e\n\n\u003cp\u003eReturn \u003cem\u003ethe longest \u003cstrong\u003eZigZag\u003c/strong\u003e path contained in that tree\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/01/22/sample_1_1702.png\" style=\"width: 221px; height: 383px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 3\n\u003cstrong\u003eExplanation:\u003c/strong\u003e Longest ZigZag path in blue nodes (right -\u0026gt; left -\u0026gt; right).\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/01/22/sample_2_1702.png\" style=\"width: 157px; height: 329px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,1,1,null,1,null,null,1,1,null,1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 4\n\u003cstrong\u003eExplanation:\u003c/strong\u003e Longest ZigZag path in blue nodes (left -\u0026gt; right -\u0026gt; left -\u0026gt; right).\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 0\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 5 * 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= Node.val \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": [
        "Dynamic Programming",
        "Tree",
        "Depth-First Search",
        "Binary Tree"
      ]
    },
    {
      "title": "Second Minimum Node In a Binary Tree",
      "titleSlug": "second-minimum-node-in-a-binary-tree",
      "difficulty": "Easy",
      "content": "\u003cp\u003eGiven a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly \u003ccode\u003etwo\u003c/code\u003e or \u003ccode\u003ezero\u003c/code\u003e sub-node. If the node has two sub-nodes, then this node\u0026#39;s value is the smaller value among its two sub-nodes. More formally, the property\u0026nbsp;\u003ccode\u003eroot.val = min(root.left.val, root.right.val)\u003c/code\u003e\u0026nbsp;always holds.\u003c/p\u003e\n\n\u003cp\u003eGiven such a binary tree, you need to output the \u003cb\u003esecond minimum\u003c/b\u003e value in the set made of all the nodes\u0026#39; value in the whole tree.\u003c/p\u003e\n\n\u003cp\u003eIf no such second minimum value exists, output -1 instead.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/15/smbt1.jpg\" style=\"width: 431px; height: 302px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [2,2,5,null,null,5,7]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 5\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The smallest value is 2, the second smallest value is 5.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/15/smbt2.jpg\" style=\"width: 321px; height: 182px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [2,2,2]\n\u003cstrong\u003eOutput:\u003c/strong\u003e -1\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The smallest value is 2, but there isn\u0026#39;t any second smallest value.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 25]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= Node.val \u0026lt;= 2\u003csup\u003e31\u003c/sup\u003e - 1\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eroot.val == min(root.left.val, root.right.val)\u003c/code\u003e\u0026nbsp;for each internal node of the tree.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": ["Tree", "Depth-First Search", "Binary Tree"]
    },
    {
      "title": "All Nodes Distance K in Binary Tree",
      "titleSlug": "all-nodes-distance-k-in-binary-tree",
      "difficulty": "Medium",
      "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a binary tree, the value of a target node \u003ccode\u003etarget\u003c/code\u003e, and an integer \u003ccode\u003ek\u003c/code\u003e, return \u003cem\u003ean array of the values of all nodes that have a distance \u003c/em\u003e\u003ccode\u003ek\u003c/code\u003e\u003cem\u003e from the target node.\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003eYou can return the answer in \u003cstrong\u003eany order\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png\" style=\"width: 500px; height: 429px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2\n\u003cstrong\u003eOutput:\u003c/strong\u003e [7,4,1]\nExplanation: The nodes that are a distance 2 from the target node (with value 5) have values 7, 4, and 1.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1], target = 1, k = 3\n\u003cstrong\u003eOutput:\u003c/strong\u003e []\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 500]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= Node.val \u0026lt;= 500\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eAll the values \u003ccode\u003eNode.val\u003c/code\u003e are \u003cstrong\u003eunique\u003c/strong\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003etarget\u003c/code\u003e is the value of one of the nodes in the tree.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= k \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": [
        "Hash Table",
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ]
    },
    {
      "title": "Kth Largest Sum in a Binary Tree",
      "titleSlug": "kth-largest-sum-in-a-binary-tree",
      "difficulty": "Medium",
      "content": "\u003cp\u003eYou are given the \u003ccode\u003eroot\u003c/code\u003e of a binary tree and a positive integer \u003ccode\u003ek\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe \u003cstrong\u003elevel sum\u003c/strong\u003e in the tree is the sum of the values of the nodes that are on the \u003cstrong\u003esame\u003c/strong\u003e level.\u003c/p\u003e\n\n\u003cp\u003eReturn\u003cem\u003e the \u003c/em\u003e\u003ccode\u003ek\u003csup\u003eth\u003c/sup\u003e\u003c/code\u003e\u003cem\u003e \u003cstrong\u003elargest\u003c/strong\u003e level sum in the tree (not necessarily distinct)\u003c/em\u003e. If there are fewer than \u003ccode\u003ek\u003c/code\u003e levels in the tree, return \u003ccode\u003e-1\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eNote\u003c/strong\u003e that two nodes are on the same level if they have the same distance from the root.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/14/binaryytreeedrawio-2.png\" style=\"width: 301px; height: 284px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [5,8,9,2,1,3,7,4,6], k = 2\n\u003cstrong\u003eOutput:\u003c/strong\u003e 13\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The level sums are the following:\n- Level 1: 5.\n- Level 2: 8 + 9 = 17.\n- Level 3: 2 + 1 + 3 + 7 = 13.\n- Level 4: 4 + 6 = 10.\nThe 2\u003csup\u003end\u003c/sup\u003e largest level sum is 13.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/14/treedrawio-3.png\" style=\"width: 181px; height: 181px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2,null,3], k = 1\n\u003cstrong\u003eOutput:\u003c/strong\u003e 3\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The largest level sum is 3.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is \u003ccode\u003en\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e2 \u0026lt;= n \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= Node.val \u0026lt;= 10\u003csup\u003e6\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= k \u0026lt;= n\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": ["Tree", "Breadth-First Search", "Sorting", "Binary Tree"]
    },
    {
      "title": "Construct Binary Tree from Preorder and Inorder Traversal",
      "titleSlug": "construct-binary-tree-from-preorder-and-inorder-traversal",
      "difficulty": "Medium",
      "content": "\u003cp\u003eGiven two integer arrays \u003ccode\u003epreorder\u003c/code\u003e and \u003ccode\u003einorder\u003c/code\u003e where \u003ccode\u003epreorder\u003c/code\u003e is the preorder traversal of a binary tree and \u003ccode\u003einorder\u003c/code\u003e is the inorder traversal of the same tree, construct and return \u003cem\u003ethe binary tree\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree.jpg\" style=\"width: 277px; height: 302px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [3,9,20,null,null,15,7]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e preorder = [-1], inorder = [-1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [-1]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= preorder.length \u0026lt;= 3000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003einorder.length == preorder.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-3000 \u0026lt;= preorder[i], inorder[i] \u0026lt;= 3000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003epreorder\u003c/code\u003e and \u003ccode\u003einorder\u003c/code\u003e consist of \u003cstrong\u003eunique\u003c/strong\u003e values.\u003c/li\u003e\n\t\u003cli\u003eEach value of \u003ccode\u003einorder\u003c/code\u003e also appears in \u003ccode\u003epreorder\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003epreorder\u003c/code\u003e is \u003cstrong\u003eguaranteed\u003c/strong\u003e to be the preorder traversal of the tree.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003einorder\u003c/code\u003e is \u003cstrong\u003eguaranteed\u003c/strong\u003e to be the inorder traversal of the tree.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": [
        "Array",
        "Hash Table",
        "Divide and Conquer",
        "Tree",
        "Binary Tree"
      ]
    },
    {
      "title": "Construct Binary Tree from Inorder and Postorder Traversal",
      "titleSlug": "construct-binary-tree-from-inorder-and-postorder-traversal",
      "difficulty": "Medium",
      "content": "\u003cp\u003eGiven two integer arrays \u003ccode\u003einorder\u003c/code\u003e and \u003ccode\u003epostorder\u003c/code\u003e where \u003ccode\u003einorder\u003c/code\u003e is the inorder traversal of a binary tree and \u003ccode\u003epostorder\u003c/code\u003e is the postorder traversal of the same tree, construct and return \u003cem\u003ethe binary tree\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree.jpg\" style=\"width: 277px; height: 302px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [3,9,20,null,null,15,7]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e inorder = [-1], postorder = [-1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [-1]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= inorder.length \u0026lt;= 3000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003epostorder.length == inorder.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-3000 \u0026lt;= inorder[i], postorder[i] \u0026lt;= 3000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003einorder\u003c/code\u003e and \u003ccode\u003epostorder\u003c/code\u003e consist of \u003cstrong\u003eunique\u003c/strong\u003e values.\u003c/li\u003e\n\t\u003cli\u003eEach value of \u003ccode\u003epostorder\u003c/code\u003e also appears in \u003ccode\u003einorder\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003einorder\u003c/code\u003e is \u003cstrong\u003eguaranteed\u003c/strong\u003e to be the inorder traversal of the tree.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003epostorder\u003c/code\u003e is \u003cstrong\u003eguaranteed\u003c/strong\u003e to be the postorder traversal of the tree.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": [
        "Array",
        "Hash Table",
        "Divide and Conquer",
        "Tree",
        "Binary Tree"
      ]
    },
    {
      "title": "Minimum Flips in Binary Tree to Get Result",
      "titleSlug": "minimum-flips-in-binary-tree-to-get-result",
      "difficulty": "Hard",
      "content": "",
      "tags": [
        "Dynamic Programming",
        "Tree",
        "Depth-First Search",
        "Binary Tree"
      ]
    },
    {
      "title": "Lowest Common Ancestor of a Binary Tree II",
      "titleSlug": "lowest-common-ancestor-of-a-binary-tree-ii",
      "difficulty": "Medium",
      "content": "",
      "tags": ["Tree", "Depth-First Search", "Binary Tree"]
    },
    {
      "title": "Lowest Common Ancestor of a Binary Tree III",
      "titleSlug": "lowest-common-ancestor-of-a-binary-tree-iii",
      "difficulty": "Medium",
      "content": "",
      "tags": ["Hash Table", "Two Pointers", "Tree", "Binary Tree"]
    },
    {
      "title": "Lowest Common Ancestor of a Binary Tree IV",
      "titleSlug": "lowest-common-ancestor-of-a-binary-tree-iv",
      "difficulty": "Medium",
      "content": "",
      "tags": ["Hash Table", "Tree", "Depth-First Search", "Binary Tree"]
    },
    {
      "title": "Construct Binary Tree from Preorder and Postorder Traversal",
      "titleSlug": "construct-binary-tree-from-preorder-and-postorder-traversal",
      "difficulty": "Medium",
      "content": "\u003cp\u003eGiven two integer arrays, \u003ccode\u003epreorder\u003c/code\u003e and \u003ccode\u003epostorder\u003c/code\u003e where \u003ccode\u003epreorder\u003c/code\u003e is the preorder traversal of a binary tree of \u003cstrong\u003edistinct\u003c/strong\u003e values and \u003ccode\u003epostorder\u003c/code\u003e is the postorder traversal of the same tree, reconstruct and return \u003cem\u003ethe binary tree\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf there exist multiple answers, you can \u003cstrong\u003ereturn any\u003c/strong\u003e of them.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/24/lc-prepost.jpg\" style=\"width: 304px; height: 265px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,2,3,4,5,6,7]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e preorder = [1], postorder = [1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= preorder.length \u0026lt;= 30\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= preorder[i] \u0026lt;= preorder.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eAll the values of \u003ccode\u003epreorder\u003c/code\u003e are \u003cstrong\u003eunique\u003c/strong\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003epostorder.length == preorder.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= postorder[i] \u0026lt;= postorder.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eAll the values of \u003ccode\u003epostorder\u003c/code\u003e are \u003cstrong\u003eunique\u003c/strong\u003e.\u003c/li\u003e\n\t\u003cli\u003eIt is guaranteed that \u003ccode\u003epreorder\u003c/code\u003e and \u003ccode\u003epostorder\u003c/code\u003e are the preorder traversal and postorder traversal of the same binary tree.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": [
        "Array",
        "Hash Table",
        "Divide and Conquer",
        "Tree",
        "Binary Tree"
      ]
    },
    {
      "title": "Height of Binary Tree After Subtree Removal Queries",
      "titleSlug": "height-of-binary-tree-after-subtree-removal-queries",
      "difficulty": "Hard",
      "content": "\u003cp\u003eYou are given the \u003ccode\u003eroot\u003c/code\u003e of a \u003cstrong\u003ebinary tree\u003c/strong\u003e with \u003ccode\u003en\u003c/code\u003e nodes. Each node is assigned a unique value from \u003ccode\u003e1\u003c/code\u003e to \u003ccode\u003en\u003c/code\u003e. You are also given an array \u003ccode\u003equeries\u003c/code\u003e of size \u003ccode\u003em\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eYou have to perform \u003ccode\u003em\u003c/code\u003e \u003cstrong\u003eindependent\u003c/strong\u003e queries on the tree where in the \u003ccode\u003ei\u003csup\u003eth\u003c/sup\u003e\u003c/code\u003e query you do the following:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003cstrong\u003eRemove\u003c/strong\u003e the subtree rooted at the node with the value \u003ccode\u003equeries[i]\u003c/code\u003e from the tree. It is \u003cstrong\u003eguaranteed\u003c/strong\u003e that \u003ccode\u003equeries[i]\u003c/code\u003e will \u003cstrong\u003enot\u003c/strong\u003e be equal to the value of the root.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eReturn \u003cem\u003ean array \u003c/em\u003e\u003ccode\u003eanswer\u003c/code\u003e\u003cem\u003e of size \u003c/em\u003e\u003ccode\u003em\u003c/code\u003e\u003cem\u003e where \u003c/em\u003e\u003ccode\u003eanswer[i]\u003c/code\u003e\u003cem\u003e is the height of the tree after performing the \u003c/em\u003e\u003ccode\u003ei\u003csup\u003eth\u003c/sup\u003e\u003c/code\u003e\u003cem\u003e query\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eNote\u003c/strong\u003e:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe queries are independent, so the tree returns to its \u003cstrong\u003einitial\u003c/strong\u003e state after each query.\u003c/li\u003e\n\t\u003cli\u003eThe height of a tree is the \u003cstrong\u003enumber of edges in the longest simple path\u003c/strong\u003e from the root to some node in the tree.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/09/07/binaryytreeedrawio-1.png\" style=\"width: 495px; height: 281px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,3,4,2,null,6,5,null,null,null,null,null,7], queries = [4]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [2]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The diagram above shows the tree after removing the subtree rooted at node with value 4.\nThe height of the tree is 2 (The path 1 -\u0026gt; 3 -\u0026gt; 2).\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/09/07/binaryytreeedrawio-2.png\" style=\"width: 301px; height: 284px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [5,8,9,2,1,3,7,4,6], queries = [3,2,4,8]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [3,2,3,2]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e We have the following queries:\n- Removing the subtree rooted at node with value 3. The height of the tree becomes 3 (The path 5 -\u0026gt; 8 -\u0026gt; 2 -\u0026gt; 4).\n- Removing the subtree rooted at node with value 2. The height of the tree becomes 2 (The path 5 -\u0026gt; 8 -\u0026gt; 1).\n- Removing the subtree rooted at node with value 4. The height of the tree becomes 3 (The path 5 -\u0026gt; 8 -\u0026gt; 2 -\u0026gt; 6).\n- Removing the subtree rooted at node with value 8. The height of the tree becomes 2 (The path 5 -\u0026gt; 9 -\u0026gt; 3).\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is \u003ccode\u003en\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e2 \u0026lt;= n \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= Node.val \u0026lt;= n\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eAll the values in the tree are \u003cstrong\u003eunique\u003c/strong\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003em == queries.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= m \u0026lt;= min(n, 10\u003csup\u003e4\u003c/sup\u003e)\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= queries[i] \u0026lt;= n\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003equeries[i] != root.val\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": [
        "Array",
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ]
    },
    {
      "title": "Is Array a Preorder of Some Binary Tree",
      "titleSlug": "is-array-a-preorder-of-some-binary-tree",
      "difficulty": "Medium",
      "content": "",
      "tags": ["Stack", "Tree", "Depth-First Search", "Binary Tree"]
    },
    {
      "title": "Amount of Time for Binary Tree to Be Infected",
      "titleSlug": "amount-of-time-for-binary-tree-to-be-infected",
      "difficulty": "Medium",
      "content": "\u003cp\u003eYou are given the \u003ccode\u003eroot\u003c/code\u003e of a binary tree with \u003cstrong\u003eunique\u003c/strong\u003e values, and an integer \u003ccode\u003estart\u003c/code\u003e. At minute \u003ccode\u003e0\u003c/code\u003e, an \u003cstrong\u003einfection\u003c/strong\u003e starts from the node with value \u003ccode\u003estart\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eEach minute, a node becomes infected if:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe node is currently uninfected.\u003c/li\u003e\n\t\u003cli\u003eThe node is adjacent to an infected node.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eReturn \u003cem\u003ethe number of minutes needed for the entire tree to be infected.\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/25/image-20220625231744-1.png\" style=\"width: 400px; height: 306px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,5,3,null,4,10,6,9,2], start = 3\n\u003cstrong\u003eOutput:\u003c/strong\u003e 4\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The following nodes are infected during:\n- Minute 0: Node 3\n- Minute 1: Nodes 1, 10 and 6\n- Minute 2: Node 5\n- Minute 3: Node 4\n- Minute 4: Nodes 9 and 2\nIt takes 4 minutes for the whole tree to be infected so we return 4.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/25/image-20220625231812-2.png\" style=\"width: 75px; height: 66px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1], start = 1\n\u003cstrong\u003eOutput:\u003c/strong\u003e 0\n\u003cstrong\u003eExplanation:\u003c/strong\u003e At minute 0, the only node in the tree is infected so we return 0.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 10\u003csup\u003e5\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= Node.val \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eEach node has a \u003cstrong\u003eunique\u003c/strong\u003e value.\u003c/li\u003e\n\t\u003cli\u003eA node with a value of \u003ccode\u003estart\u003c/code\u003e exists in the tree.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": [
        "Hash Table",
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ]
    },
    {
      "title": "Make Costs of Paths Equal in a Binary Tree",
      "titleSlug": "make-costs-of-paths-equal-in-a-binary-tree",
      "difficulty": "Medium",
      "content": "\u003cp\u003eYou are given an integer \u003ccode\u003en\u003c/code\u003e representing the number of nodes in a \u003cstrong\u003eperfect binary tree\u003c/strong\u003e consisting of nodes numbered from \u003ccode\u003e1\u003c/code\u003e to \u003ccode\u003en\u003c/code\u003e. The root of the tree is node \u003ccode\u003e1\u003c/code\u003e and each node \u003ccode\u003ei\u003c/code\u003e in the tree has two children where the left child is the node \u003ccode\u003e2 * i\u003c/code\u003e and the right child is \u003ccode\u003e2 * i + 1\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eEach node in the tree also has a \u003cstrong\u003ecost\u003c/strong\u003e represented by a given \u003cstrong\u003e0-indexed\u003c/strong\u003e integer array \u003ccode\u003ecost\u003c/code\u003e of size \u003ccode\u003en\u003c/code\u003e where \u003ccode\u003ecost[i]\u003c/code\u003e is the cost of node \u003ccode\u003ei + 1\u003c/code\u003e. You are allowed to \u003cstrong\u003eincrement\u003c/strong\u003e the cost of \u003cstrong\u003eany\u003c/strong\u003e node by \u003ccode\u003e1\u003c/code\u003e \u003cstrong\u003eany\u003c/strong\u003e number of times.\u003c/p\u003e\n\n\u003cp\u003eReturn \u003cem\u003ethe \u003cstrong\u003eminimum\u003c/strong\u003e number of increments you need to make the cost of paths from the root to each \u003cstrong\u003eleaf\u003c/strong\u003e node equal\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eNote\u003c/strong\u003e:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eA \u003cstrong\u003eperfect binary tree \u003c/strong\u003eis a tree where each node, except the leaf nodes, has exactly 2 children.\u003c/li\u003e\n\t\u003cli\u003eThe \u003cstrong\u003ecost of a path\u003c/strong\u003e is the sum of costs of nodes in the path.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/04/binaryytreeedrawio-4.png\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 7, cost = [1,5,2,2,3,3,1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 6\n\u003cstrong\u003eExplanation:\u003c/strong\u003e We can do the following increments:\n- Increase the cost of node 4 one time.\n- Increase the cost of node 3 three times.\n- Increase the cost of node 7 two times.\nEach path from the root to a leaf will have a total cost of 9.\nThe total increments we did is 1 + 3 + 2 = 6.\nIt can be shown that this is the minimum answer we can achieve.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/04/binaryytreee2drawio.png\" style=\"width: 205px; height: 151px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 3, cost = [5,3,3]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 0\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The two paths already have equal total costs, so no increments are needed.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e3 \u0026lt;= n \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003en + 1\u003c/code\u003e is a power of \u003ccode\u003e2\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ecost.length == n\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= cost[i] \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": ["Array", "Dynamic Programming", "Greedy", "Tree", "Binary Tree"]
    },
    {
      "title": "K-th Largest Perfect Subtree Size in Binary Tree",
      "titleSlug": "k-th-largest-perfect-subtree-size-in-binary-tree",
      "difficulty": "Medium",
      "content": "\u003cp\u003eYou are given the \u003ccode\u003eroot\u003c/code\u003e of a \u003cstrong\u003ebinary tree\u003c/strong\u003e and an integer \u003ccode\u003ek\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eReturn an integer denoting the size of the \u003ccode\u003ek\u003csup\u003eth\u003c/sup\u003e\u003c/code\u003e \u003cstrong\u003elargest\u003cem\u003e \u003c/em\u003eperfect binary\u003c/strong\u003e\u003cem\u003e \u003c/em\u003e\u003cspan data-keyword=\"subtree\"\u003esubtree\u003c/span\u003e, or \u003ccode\u003e-1\u003c/code\u003e if it doesn\u0026#39;t exist.\u003c/p\u003e\n\n\u003cp\u003eA \u003cstrong\u003eperfect binary tree\u003c/strong\u003e is a tree where all leaves are on the same level, and every parent has two children.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cdiv class=\"example-block\"\u003e\n\u003cp\u003e\u003cstrong\u003eInput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003eroot = [5,3,6,5,2,5,7,1,8,null,null,6,8], k = 2\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eOutput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003e3\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eExplanation:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/10/14/tmpresl95rp-1.png\" style=\"width: 400px; height: 173px;\" /\u003e\u003c/p\u003e\n\n\u003cp\u003eThe roots of the perfect binary subtrees are highlighted in black. Their sizes, in non-increasing order are \u003ccode\u003e[3, 3, 1, 1, 1, 1, 1, 1]\u003c/code\u003e.\u003cbr /\u003e\nThe \u003ccode\u003e2\u003csup\u003end\u003c/sup\u003e\u003c/code\u003e largest size is 3.\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cdiv class=\"example-block\"\u003e\n\u003cp\u003e\u003cstrong\u003eInput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003eroot = [1,2,3,4,5,6,7], k = 1\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eOutput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003e7\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eExplanation:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/10/14/tmp_s508x9e-1.png\" style=\"width: 300px; height: 189px;\" /\u003e\u003c/p\u003e\n\n\u003cp\u003eThe sizes of the perfect binary subtrees in non-increasing order are \u003ccode\u003e[7, 3, 3, 1, 1, 1, 1]\u003c/code\u003e. The size of the largest perfect binary subtree is 7.\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong class=\"example\"\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cdiv class=\"example-block\"\u003e\n\u003cp\u003e\u003cstrong\u003eInput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003eroot = [1,2,3,null,4], k = 3\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eOutput:\u003c/strong\u003e \u003cspan class=\"example-io\"\u003e-1\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eExplanation:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/10/14/tmp74xnmpj4-1.png\" style=\"width: 250px; height: 225px;\" /\u003e\u003c/p\u003e\n\n\u003cp\u003eThe sizes of the perfect binary subtrees in non-increasing order are \u003ccode\u003e[1, 1]\u003c/code\u003e. There are fewer than 3 perfect binary subtrees.\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 2000]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= Node.val \u0026lt;= 2000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= k \u0026lt;= 1024\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "tags": ["Tree", "Depth-First Search", "Sorting", "Binary Tree"]
    }
  ]
}
